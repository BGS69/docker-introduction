<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Introduction to Docker - Catalyst Training</title>

        <meta name="author" content="Catalyst">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/catalyst.css" id="theme">
        <link rel="stylesheet" href="css/font-awesome.css">
        <link rel="stylesheet" href="css/asciinema-player.css">

        <!-- For syntax highlighting -->
        <!--<link rel="stylesheet" href="lib/css/zenburn.css">-->
        <link rel="stylesheet" href="lib/css/solarized-light.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <style>
            /* Add the ability to omit slides from the printed version (has to be after the print include)*/
            @media print {
                .reveal .slides section.no-print {
                    display: none !important;
                    visibility: hidden !important;
                }
            }
        </style>
        <style>
            .reveal h1, .reveal h2, .reveal h3 {
                color: #ba2025;
            }
        </style>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <!-- Please put any custom styles here -->
        <style>

        </style>
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <!-- Cover slide -->
                <section>
                    <h1 class="catalyst-logo">Catalyst</h1>
                    <h3>Intro to Docker</h3>
                    <p class="small-text">
                        Presented by <a href="#">Travis Holton</a>
                    </p>
                </section>

                <section>
                    <h3>Administrivia</h3>
                    <ul>
                      <li>Bathrooms</li>
                      <li>Fire exits</li>
                    </ul>
                </section>

                <section>
                    <h3>This course</h3>
                    <ul>
                        <li>Makes use of official Docker docs</li>
                        <li>Based on latest Docker</li>
                        <li>A mix of command line and theory</li>
                        <li>Assumes no prior Docker knowledge</li>
                        <li>Assumes familiarity with the linux shell</li>
                        <li>Assumes we are using ubuntu 14.04 (trusty)</li>
                    </ul>
                    <aside class="notes">
                        Introductory course so we'll start out with basic material
                        that some people may already be familiar with.
                    </aside>
                </section>

                <section>
                    <h3>Aims</h3>
                    <ul>
                        <li>Understand how to use Docker on the command line</li>
                        <li>Understand how Docker works</li>
                        <li>Learn how to integrate Docker with applications</li>
                        <li>Learn ops and developers can use Docker to deploy
                        applications</li>
                        <li>Get people thinking about where they could use Docker</li>
                    </ul>
                
                    <aside class="notes">
                        think about how you can use docker in dev, testing,
                        deploying code
                    </aside>
                </section>

                <section>
                    <section>
                        <h2>Setup</h2>
                    </section>
                    <section>
                        <h3>Fetch course resources</h3>
                        <!--<pre class="fragment" data-fragment-index="0"><code>$ git clone \
   https://github.com/catalyst-training/docker-introduction.git
$ cd docker-introduction</code></pre>-->
                        <pre class="fragment" data-fragment-index="0"><code>$ cd ~/docker-introduction
$ ls</code></pre>
                        <ul style="width:80%;">
                            <li class="fragment" data-fragment-index="1">Slides for Reveal.js presentation</li>
                            <li class="fragment" data-fragment-index="2">docker-introduction.pdf</li>
                            <li class="fragment"
                                data-fragment-index="3">Ansible setup playbook</li>
                            <li class="fragment" data-fragment-index="4">Sample code for some exercises</li>
                        </ul>


                    </section>
                    <section>
                        <h3>Ansible</h3>
                        <ul>
                          <li>
                            Some of the features we will be exploring require
                            setup. We'll use ansible for that.
                          </li>
                            <li>Python based tool set</li>
                            <li>Automate devops tasks
                                <ul>
                                    <li>server/cluster management </li>
                                    <li>installing packages</li>
                                    <li>deploying code </li>
                                    <li>managing config</li>
                                </ul>
                        </ul>
                    </section>
                    <section>
                        <h3>Setup Ansible</h3>
                        <!--<pre class="fragment" data-fragment-index="0"><code>$ git clone https://github.com/catalyst/catalystcloud-ansible.git</code></pre>-->
                        <pre class="fragment" data-fragment-index="1"><code>$ cd ~/catalystcloud-ansible
$ ./install-ansible.sh
. 
. &lt;stuff happens&gt;
.
$ source $CC_ANSIBLE_DIR/ansible-venv/bin/activate</code></pre>
                        <ul style="width:80%;" class="fragment" data-fragment-index="2">
                            <li>Installs python virtualenv with latest ansible
                            libraries</li>
                            <li>We'll be using this virtualenv for tasks
                                throughout the course.</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Setup Docker</h3>
                        <ul>
                            <li class="fragment" data-fragment-index="0">
                                Follow instructions on website for installing
                                <ul>
                                    <li><a href="https://store.docker.com/search?offering=community&type=edition">Docker Community Edition</a></li>
                                    <li><a href="https://docs.docker.com/compose/install/">docker-compose</a></li>
                                </ul>
                            </li>
                            <li class="fragment" data-fragment-index="1">If
                                you are using Ubuntu, use the ansible playbook included in course repo</li>
                            <li class="fragment" data-fragment-index="2">
                                This playbook installs:
                                <ul>
                                    <li class="fragment"
                                        data-fragment-index="3">latest Docker <em>Community Edition</em></li>
                                    <li class="fragment"
                                        data-fragment-index="4"><code>docker-compose</code></li>
                                    <li class="fragment"
                                        data-fragment-index="4">Note: you
                                        might need to logout and login again
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre class="fragment" data-fragment-index="1"><code>$ cd docker-introduction
$ ansible-playbook -K ansible/docker-install.yml</code></pre>
                        <p class="fragment" data-fragment-index="5">
                        Note: on some Ubuntu versions (eg. &ge; 16.04) you'll need to
                        add: 
                        </p>
                        <pre class="fragment" data-fragment-index="5"><code>-e ansible_python_interpreter=/usr/bin/python</code></pre>.
                        
                    </section>
                    
                    <section>
                        <h3>Fetch and run slides</h3>
                      <pre><code>$ docker run --name docker-intro -d --rm \
        -p 8000:8000 heytrav/docker-introduction-slides</code></pre>
<!--<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119477.json" cols="150" rows="15"></asciinema-player>-->
<p>
Follow along with course slides: <a href="http://localhost:8000">http://localhost:8000</a>
</p>
                    </section>
                </section>

                
                  <section>

                    <section>
                      <h2>
                        Introduction to containers
                      </h2>
                    </section>

                  <section>
                      <h3>What is containerization?</h3>
                      <ul>
                        <li>
                          A type of virtualization
                        </li>
                          
                          <li>Difference from traditional VMs
                            <ul>
                              <li>Don't replicate entire OS, just bits needed for application</li>
                              <li>Run natively on host</li>
                            </ul>
                          </li>
                          <li>
                              Key benefits:
                              <ul>
                                  <li>More lightweight than VMs</li>
                                  <li>Efficiency gains in storage, CPU</li>
                                  <li>Portability
                                      <aside class="notes">
                                          Same application container can run on any system or cloud.
                                      </aside>
                                  </li>
                              </ul>
                          </li>
                      </ul>
                      <aside class="notes">
                          
                        <ul>
                          <li>
                            Containers are a method of operating system virtualization that allow you to run an application and its dependencies in resource-isolated processes.
                          </li>
                          <li>Seem like traditional vms but...</li>
                        </ul>
                      </aside>
                      
                      
                  </section>

                  <section class="image-slide">
                      <h2>Lightweight</h2>
                      <img src="img/docker.png" alt="">
                      <aside class="notes">
                          <ul>
                              <li>Virtual machines run guest operating systems (note OS layer)</li>
                              <li>Resource intensive</li>
                              <li>
                                  Resulting disk image and application state entanglement of
                                  <ul>
                                      <li>OS Settings</li>
                                      <li>System dependencies</li>
                                      <li>OS patches</li>
                                  </ul>
                              </li>
                          </ul>
                      </aside>
                  </section>
                  <section>
                      <h3>
                          Benefits of Containers: Resources
                      </h3>
                      <ul>
                          <li>Containers share a kernel</li>
                          <li>Use less CPU than VMs</li>
                          <li>Less storage. Container image only contains:
                              <ul>
                                  <li>executable</li>
                                  <li>application dependencies</li>
                              </ul>
                          </li>
                      </ul>
                  </section>

                <section>
                    <h3>Benefits of Containers: Decoupling</h3>
                    <div style="float:left;width:50%"><ul>
                        <li>Application stack not coupled to host machine</li>
                        <li>Scale and upgrade services independently</li>
                        <li>Treat services like cattle instead of pets </li>
                      </ul></div>
                      <div style="float:left;width:50%"><img src="img/immutable_infrastructure.gif" /></div>
                    <aside class="notes">Scale services, not machines. You *can* treat machines like cattle, not pets.</aside>
                </section>
                <section>
                    <h3>Benefits of Containers: Workflows</h3>
                    <ul>
                      <li>Easy to distribute</li>
                      <li>Developers can wrap application with libs and dependencies as a single package </li>
                      <li>
                        Easy to move code from development environments to
                        production in easy and replicable fashion 
                      </li>
                    </ul>
                </section>
                  </section>
                  <section>
                    <section>
                      <h2>
                        Introduction to Docker
                      </h2>
                      <h3>The Docker Platform</h3>
<aside class="notes">
                            An open-source platform for creating,
                            running, and distributing software "containers"
                            that bundle software applications with all of
                            their dependencies.
                        </aside>
                    </section>

                    <section>
                      <h3>What is Docker?</h3>
                      <dl>
                        <dt>High level</dt>
                        <dd>
                        An open-source platform for creating,
                        running, and distributing software <em>containers</em>
                        that bundle software applications with all of
                        their dependencies.
                        </dd>
                        <dt>Low level</dt>
                        <dd>
                        A command-line tool for programmatically defining the contents of a Linux container in code, which can then be versioned, reproduced, shared, and modified easily just as if it were the source code to a program
                        </dd>
                      </dl>
                    </section>
                    
                    <section>
                        <h3>Docker popularity</h3>
                        <ul>
                            <li class="fragment" data-fragment-index="0">Linux containers are not new
                              <ul>
                                <li>FreeBSD Jails</li>
                                <li>LXC containers</li>
                                <li>Solaris Zones</li>
                              </ul>
                              </li>
                              <li class="fragment" data-fragment-index="1">Docker is doing for containers what Vagrant did for virtual machines
                                <ul>
                                  <li>Easy to create</li>
                                  <li>Easy to distribute</li>
                                </ul>
                              </li>
                        </ul>
                    </section>

                    <section>
                        <h3>Docker workflow</h3>
                        
                        <ul>
                            <li class="fragment" data-fragment-index="0">Developer packages application and supporting components into image</li>
                            <li class="fragment" data-fragment-index="1">Developer/CI pushes image to private or public registry</li>
                            <li class="fragment" data-fragment-index="2">The image becomes the unit for distributing and testing your application.  </li>
                        </ul>
                      <img  class="fragment" data-fragment-index="2"src="img/Diapositive1.png" alt="Developer workflow">
                        <aside class="notes">
                            <p>
                            Docker has created a platform that makes it easy
                            to create and distribute containerised
                            applications
                            </p>
                        
                        <p>
                        The collective tooling that enables you to...
                        </p>    <ul>
                                <li>Provides the ability to package and run an application in a loosely
                                isolated environment called a container. </li>
                                <li>The isolation and security allow you to run many containers simultaneously on a given host. </li>
                                <li>They don’t need the extra load of a hypervisor, but run directly within the host machine’s kernel. </li>
                                <li>Can run more containers on a given hardware combination than using virtual machines.</li>
                            </ul>
                        </aside>

                    </section>
                    <!--<section>
                        <h3>The Docker Engine</h3>
                        <aside class="notes">
                            <p>
                            Client server application
                            </p>
                            <p>
                            The CLI uses the Docker REST API to control or
                            interact with the Docker daemon through scripting or
                            direct CLI commands. Many other Docker applications
                            use the underlying API and CLI.
                            </p>
                            <p>
                            The daemon creates and manages Docker objects, such as
                            images, containers, networks, and volumes.
                            </p>
                        </aside>
                        <ul>
                            <li>A server which is a type of long-running program called a daemon process (the dockerd command).</li>
                            <li>A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do.</li>
                            <li>A command line interface (CLI) client (the docker command).</li>
                        </ul>
                        <img src="img/engine-components-flow.png" alt="Docker Engine">
                    </section>-->
                    <!--<section>
                        <h3>Uses of Docker</h3>
                        <ul>
                            <li>Fast consistent delivery of applications </li>
                            <li>Responsive deployment and scaling</li>
                            <li>Running more workloads on same hardware</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Standardised environment across development, testing, production</li>
                                <li>Ideal for CI/CD workflows</li>
                                <li>Containers can run on multiple environments</li>
                                <li>Portability and Lightweight make scaling easy</li>
                                <li>Can run more on the same hardware</li>
                            </ul>
                        </aside>
                    </section>-->
                  

                    <section>
                        <h3>Docker Portability</h3>

                        <ul>
                            <li>Most modern operating systems
                                <ul>
                                    <li>Linux (RHEL, CentOS, Ubuntu LTS, etc.)</li>
                                    <li>OSX </li>
                                    <li>Windows</li>
                                </ul>
                            </li>
                            <li>Lightweight Docker optimized Linux distributions (CoreOS, Project Atomic, RancherOS, etc.)</li>
                            <li>Private clouds (OpenStack, Vmware)</li>
                            <li>Public clouds (AWS, Azure, Rackspace, Google)</li>
                        </ul>

                    </section>





                  <section>
                    <h3>Docker Registries</h3>
                    <div style="float:left;width:50%">
                      <ul>
                        <li>Public repositories for docker images
                          <ul>
                            <li><a href="https://hub.docker.com">Docker Hub</a></li>
                            <li><a href="https://quay.io">Quay.io</a></li>
                            <li>GitLab ships with docker registry</li>
                          </ul>
                        </li>
                        <li>
                          Create your own private registry
                          <a href="https://github.com/docker/distribution">docker/distribution</a>
                        </li>
                      </ul>
                    </div>
                    <div style="float:left;width:50%">
                      <img src="img/docker-hub.png" />
                    </div>
                  </section>
                  </section>
                <section>
                    <section>
                        <h2>First Steps with Docker</h2>
                    </section>
                  <section>
                      <h3>
                          Docker version
                      </h3>

                      <pre><code>$ docker --version
Docker version 17.03.1-ce, build c6d412e</code></pre>
                      <p>Current version scheme similar to Ubuntu versioning: <code>YY.MM.#</code></p>
                    
                  </section>
                  <section>
                      <h3>Get command documentation</h3>
                      <ul>
                          <li>Just typing <code style="color:red;">docker</code> returns list of commands</li>
                          <li>Calling any command with <code
                                  style="color:red;">-h</code> or <code
                                  style="color:red;">--help</code> displays some docs</li>
                          <li>Comprehensive online docs on <a href="https://docs.docker.com/edge/engine/reference/commandline/docker/">Docker website</a></li>
                      </ul>
                  </section>
                    <section>
                      <h3>
                        Basic client usage
                      </h3>
                      <p>
                      <code>docker</code> <code
                          style="color:red">command</code> <code
                          style="color:blue;font-style:italic">[options] [args]</code>
                      </p>
                      <pre><code>$ docker&lt;ENTER&gt;

    Usage:  docker COMMAND

    A self-sufficient runtime for containers

    Options:
          --config string      Location of client config files (default "/Users/travis/.docker")
      -D, --debug              Enable debug mode
          --help               Print usage
    .
    .</code></pre>
                    </section>
                    
                  <section>
                     <h4>Exercise: View documentation for <code>docker run</code></h4>
                    <pre class="fragment" data-fragment-index="0"><code>$ docker run --help
Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

Run a command in a new container

Options:
      --add-host list                  Add a custom host-to-IP mapping (host:ip)
  -a, --attach list                    Attach to STDIN, STDOUT or STDERR
      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)
      --blkio-weight-device list       Block IO weight (relative device weight) (default [])
      .
      .  </code></pre>
                  </section>
                  <section>
                    <h3>Docker <code>run</code></h3> 
                    <h4>Run a command in a container from an image
                    </h4>                        <p>
                        <code>docker</code> <code >run</code>
                        <code style="color:purple">[options]</code> <code
                        style="color:red;font-style:italic">image</code> <code style="color:blue;font-style:italic">[command]</code>
                        </p>
                        <ul class="fragment" data-fragment-index="0">
                            <li>
                                <code>docker run</code> requires an <code style="color:red">image</code> argument
                            </li>
                        </ul>
                        
                        <table class="fragment" data-fragment-index="1">
                          <tr>
                            <th>Option</th>
                            <th>Argument</th>
                            <th>Description </th>
                          </tr>
                          <tr><td>-i     </td><th>         </th>      <td>Keep STDIN open</td></tr>
                          <tr><td>-t     </td><th>         </th>      <td>Allocate a tty</td></tr>
                          <tr><td>--rm   </td><th>         </th>      <td>Automatically remove container on exit</td></tr>
                          <tr><td>-v     </td><th>  list   </th>      <td>Mount a volume</td></tr>
                          <tr><td>-p     </td><th>  list   </th>      <td>List of port mappings</td></tr>
                          <tr><td>-e, --env     </td><th>  list   </th>
                            <td>Set environment variables</td></tr>
                          <tr><td>-d, --detach     </td><th></th>      <td>Run
                            container in background and print container ID</td></tr>
                          <tr><td>--link </td><th>  list   </th>      <td>Add link to another container</td></tr>
                          <tr><td>--name </td><th>  string </th>      <td>Name for the container</td></tr>
                        </table>
                        <p class="fragment" data-fragment-index="1">
                       These are just
                        examples that we'll use in the course. 
                        See complete
                        list with <code>docker run --help</code>
                        </p>
                        
                  </section>

                    <section>
                        <h3>
                            Run a simple container
                        </h3>
                        <pre><code>$ docker run hello-world</code></pre>
<asciinema-player autoplay="1" loop="loop" font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-122666.json" cols="150" rows="10"></asciinema-player>
  <p>
  The hello-world image was created by docker for instructional purposes. It
  just outputs a <em>hello world</em>-like message and exits.
  </p>
                    </section>
                    
                  <section>
                    <h3>
                      Start a shell
                    </h3>
                      <p>
                      <code>docker</code> <code >run</code>
                      <code style="color:green;">image</code>
                      <code style="color:blue;font-style:italic">[command]</code>
                      </p>
                     <pre><code>$ docker run alpine /bin/sh</code></pre> 
                    <ul>
                      <li class="fragment" data-fragment-index="0">Docker
                          starts container using alpine image</li>
                        <li class="fragment" data-fragment-index="1">
                            <code >[command]</code> argument is executed
                            inside container
                            
                        </li>
                      <li class="fragment" data-fragment-index="2">Exits immediately</li>
                      <li class="fragment" data-fragment-index="3">A docker container only runs as long as it has a process (eg. a shell terminal or program) to run</li>
                    </ul>
 <asciinema-player class="fragment" data-fragment-index="1" autoplay="1" loop="loop"  font-size="medium" speed="1"
     theme="solarized-light" src="lib/asciicast-119489.json" cols="174" rows="3"></asciinema-player>
                  </section>



                    
                  <section>
                    
<h4>Exercise: Start an <em>interactive</em> shell</h4>
                      <p>
                      <code>docker</code> <code >run</code> <code style="color:red;">[options]</code> <code >alpine</code> <code>/bin/sh</code>
                      </p>
                    <pre class="fragment" data-fragment-index="0"><code>$ docker run -it alpine /bin/sh</code></pre>
<asciinema-player class="fragment" data-fragment-index="0" autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-119490.json" cols="174" rows="5"></asciinema-player>
                    <ul style="width:80%;">
                      <li class="fragment" data-fragment-index="0">Docker starts alpine image
                        <ul>
                          <li><code>-i</code> interactively</li>
                          <li><code>-t</code> allocate a pseudo-TTY</li>
                        </ul>
                      </li>
                      <li class="fragment" data-fragment-index="1">Runs shell command</li>
                      <li class="fragment" data-fragment-index="2">Execute commands inside container</li>
                          <li class="fragment" data-fragment-index="3">
                              Exiting the shell stops the process and the
                              container
                          </li>
                    </ul>
                  </section>
                  <section>
                    <h3>List running containers</h3>
                    <h4><code>docker ps</code></h4>
                    <pre  class="fragment" data-fragment-index="0"
                    style="width:100%"><code>$ docker ps
                    
CONTAINER ID  IMAGE                                ... NAMES
b3169acf49f8  alpine                               ... adoring_edison
02aa3e50580c  heytrav/docker-introduction-slides   ... docker-intro</code></pre>
                    <p class="fragment" data-fragment-index="1">
                    Note: by default docker will assign a random name to each
                    container (i.e. <em>adoring_edison</em>).
                    </p>
                        
   <table class="fragment" data-fragment-index="2">
     <tr>
       <th>Option                  </th>
       <th>Argument</th>
       <th>Description</th>
     </tr>

     <tr><td><code>-a, --all      </code></td><td>            </td><td> Show all containers (default shows just running)</td></tr>
     <tr><td><code>-f, --filter   </code></td><td> filter     </td><td>    Filter output based on conditions provided</td></tr>
     <tr><td><code>    --format   </code></td><td> string     </td><td>    Pretty-print containers using a Go template</td></tr>
     <tr><td><code>    --help     </code></td><td>            </td><td> Print usage</td></tr>
     <tr><td><code>    --no-trunc </code></td><td>            </td><td> Don't truncate output</td></tr>
   </table>
                    
                  </section>
                  <section>
                      <h4>
                          Exercise: Assign the name <em>myalpine</em> when running
                          previous example container
                      </h4>
                      
                      <p>Hint: <code>docker run -it </code><code style="color:red;">&lt;option&gt;</code><code> alpine</code></p>
                    <pre class="fragment" style="width:100%;" data-fragment-index="0"><code>$ docker run -it --name myalpine alpine /bin/sh</code></pre>
                    
                    <pre class="fragment" style="width:100%;" data-fragment-index="1"><code>❯ docker ps
CONTAINER ID        IMAGE                                ...   NAMES
db1faf244e7a        alpine                               ...   myalpine
02aa3e50580c        heytrav/docker-introduction-slides   ...   docker-intro</code></pre>
                    <ul style="width:80%;">
                        <li class="fragment" data-fragment-index="2">Exit the shell</li>
                        <li class="fragment" data-fragment-index="2">Repeat
                            using same name.
                            What happens?</li>
                    </ul>
<asciinema-player  class="fragment" data-fragment-index="3" autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/name-in-use-error.json" cols="200"
    rows="6"></asciinema-player>
                    
                    
                  </section>
                  <section>
                    <h3>Removing containers</h3>
                    <p class="fragment" data-fragment-index="0">
                    <code>docker</code> <code style="color:red;">rm</code> <code style="color:green;">name|containerID</code>
                    </p>
                  </section>

                  <section>
                    <h4>Exercise: remove old <code>myalpine</code> container</h4>
                    <pre class="fragment" data-fragment-index="0"><code>$ docker rm myalpine</code></pre>
<asciinema-player  class="fragment" data-fragment-index="0" autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/remove-container.json" cols="200" rows="12"></asciinema-player>
<p class="fragment" data-fragment-index="1">
If you pass the <code style="color:red;">--rm</code> flag to <code>docker run</code>, containers will be cleaned up when
stopped.
</p>
                  </section>
                  <section>
                    
                    <h4>
                      Exercise: Run website in a container
                    </h4>
                    <ul>
                      <li>Run the image: <code style="color:red;">dockersamples/static-site</code></li>
                      <li>Name it <em>static-site</em></li>
                      <li>Pass your name to the <code>AUTHOR</code> environment variable</li>
                      <li>Map port 8081 to 80 internally (hint <code>8081:80</code>)</li>
                      <li>Container terminates when stopped</li>

                      <li>Go to <a href="http://localhost:8081">localhost:8081</a></li>
                      <li class="fragment" data-fragment-index="1">CTRL-C to exit</li>
  
                    </ul>
                    <pre class="fragment" data-fragment-index="0"><code>$ docker run --name static-site -e AUTHOR="YOUR NAME" \
    --rm -p 8081:80 dockersamples/static-site</code></pre>
<asciinema-player autoplay="1" class="fragment" data-fragment-index="0" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/static-site-v1.json" cols="120" rows="8"></asciinema-player>
                  </section>

                  
                  
                  <section>
                    <h4>Exercise: Running a detached container</h4>
                    <ul>
                      <li>
                        Run static-site container like you did before, but add
                        option to run in the background (i.e.
                        <em>detached</em> state).
                      </li>
                    </ul>

                    <pre class="fragment" data-fragment-index="0"><code>$ docker run --rm --name static-site -e AUTHOR="YOUR NAME" \
    -d -p 8081:80 dockersamples/static-site</code></pre>
<asciinema-player  class="fragment" data-fragment-index="1" autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-122718.json" cols="120" rows="8"></asciinema-player>
                    
                    <aside class="notes">
                        <ul>
                            <li>Have users stop (<code>docker stop static-site</code>) and start this container with the exact same line</li>
                            <li>Have them run again with the <code>--rm</code> flag</li>
                        </ul>
                    </aside>

                  </section>

                  <section>
                      <h3>View container logs</h3>
                      <p>
                      <code>docker</code> <color
                      style="color:red;">logs</color> <code
                      style="color:blue;">[options]</code> <code
                  style="color:red;">CONTAINER</code>
                      </p>
<!--<script  data-autoplay="1" data-loop="1" data-size="small" data-speed="1" type="text/javascript" src="https://asciinema.org/a/122552.js" id="asciicast-122552" async></script>-->
 <table>
   <tr>
     <th>Option</th>
     <th>Argument</th>
     <th>Description</th>
   </tr>

   <tr><td><code>    --details    </code></td><td>       </td> <td>      Show extra details provided to logs</td></tr>
   <tr><td><code>-f, --follow     </code></td><td>       </td> <td>      Follow log output</td></tr>
   <tr><td><code>    --help       </code></td><td>       </td> <td>      Print usage</td></tr>
   <tr><td><code>    --since      </code></td><td> string</td> <td>            Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)</td></tr>
   <tr><td><code>    --tail       </code></td><td> string</td> <td>             Number of lines to show from the end of the logs (default "all")</td></tr>
   <tr><td><code>-t, --timestamps </code></td><td>       </td> <td>      Show timestamps</td></tr>
 </table>
                                         
<p>
See <a href="https://docs.docker.com/engine/reference/commandline/logs/">online documentation</a>
</p>
                  </section>
                  <section>
                    <h4>Exercise: view container logs for <code>static-site</code> container</h4>
 <asciinema-player class="fragment" data-fragment-index="0" autoplay="1" loop="1" font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-122552.json" cols="170" rows="14"></asciinema-player>
                    <p class="fragment" data-fragment-index="1">Note: Go to <a href="http://localhost:8081">localhost:8081</a> and refresh a few times</p>
                  </section>
                  <section>
                    <h3><code>docker exec</code></h3>
                   
                    <p style="width:100%">
                    <code>docker</code> <code style="color:red;">exec </code>
                    <code style="color:purple;">[options] </code> <code
                    style="color:red;">CONTAINERID</code> <code style="color:blue;">[command]</code>
                    </p>
                    <ul style="width:80%">
                      <li>A way to interact with a running container</li>
                      <li>Open a shell inside a running container.</li>
                      <li> A bit like ssh'ing into a machine</li>
    <li>Can be useful for debugging</li>
                    <li>
                      See <a href="https://docs.docker.com/engine/reference/commandline/exec/">online documentation</a>
                    </li>                   
                    </ul>
                  </section>
                  <section>
                    <h4>
                      Exercise: Check process list in <code>static-site</code> container
                    </h4>


<asciinema-player class="fragment" data-fragment-index="0"  autoplay="1" loop="1" font-size="medium"
   theme="solarized-light" speed="1" src="lib/asciicast-122554.json" cols="150" rows="13"></asciinema-player>

                  </section>
                  <section>
                    <h3>Stop a running container</h3>
                    <p>
                    <code>docker</code> <code style="color:red;">stop</code>
                    <code style="color:green;">name|containerID</code>
                    </p>
                    
                  </section>
                  <section>
                    <h4>Exercise: Stop the <code>static-site</code> container</h4>

                    <ul>
                      <li class="fragment" data-fragment-index="0">
                        You actually have a couple options:
                        <ul>
                          <li class="fragment" data-fragment-index="1">use the name you gave to the container</li>
                          <li class="fragment" data-fragment-index="2">use the
                              <code>containerID</code> from <code>docker
                                  ps</code> output (will depend on your
                              environment)</li>
                        </ul>
                      </li>
                    </ul>
                    <pre class="fragment" data-fragment-index="1"><code>$ docker stop static-site</code></pre>
                    <pre class="fragment" data-fragment-index="2"><code>$ docker stop 25eff330a4e4</code></pre>

                  </section>
                  <section>
                    <h3>List local images</h3>
                    <pre><code>$ docker image ls</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-119494.json" cols="174" rows="7"></asciinema-player>
                  </section>




                </section>



                <section>
                  <section>
                    <h2>How Docker works</h2>
                  </section>
                    <!--<section>
                        <h3>Components of Docker</h3>
                        <ul>
                            <li>Images
                                <ul>
                                    <li>The build component</li>
                                    <li>Distributable <em>artefact</em></li>
                                </ul>
                            </li>
                            <li>Containers
                                <ul>
                                    <li>The run component</li>
                                </ul>
                            </li>
                                
                            <li>Registries
                                <ul>
                                    <li>The distribution component</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">Remember: Images are like templates/classes, containers are like instances/objects.</aside>
                    </section>-->
                    <section class="image-slide">
                        <h3>Components of Docker</h3>
                        <img
                        src="http://alandargan.com/wp-content/uploads/2014/11/Docker2.png" alt="">
                        <aside class="notes"><ul>
                                <li>Images
                                    <ul>
                                        <li>The build component</li>
                                        <li>Distributable <em>artefact</em></li>
                                    </ul>
                                </li>
                                <li>Containers
                                    <ul>
                                        <li>The run component</li>
                                    </ul>
                                </li>

                                <li>Registries
                                    <ul>
                                        <li>The distribution component</li>
                                    </ul>
                                </li>
                            </ul></aside>
                    </section>
                    <section>
                        <h3>
                            Underlying technology
                        </h3>
                        <dl>
                            <dt>Go</dt><dd>Implementation language developed by Google</dd>
                            <dt>Namespaces</dt><dd>Provide isolated workspace, or <em>container</em></dd>
                            <dt>cgroups</dt><dd>limit application to specific set of resources </dd>
                            <dt>UnionFS</dt><dd>building blocks for containers </dd>
                            <dt>Container format</dt><dd> Combined namespaces,
                            cgroups and UnionFS</dd>
                        </dl>

                        <aside class="notes"><dl>
                               <dt>Namespace</dt> <dd>
                                    provides layer of isolation. Each container
                                    runs in isolated namepsace and only has access to
                                    components in that namespace
                                </dd>
                                <dt>cgroup</dt> 
                                <dd>
                                allow Docker Engine to share available
                                hardware resources to containers and
                                optionally enforce limits and constraints. For
                                example, you can limit the memory available to
                                a specific container.
                                </dd>
                                <dt>Union Filesystem</dt>
                                <dd>
                                operate by creating layers, making them very
                                lightweight and fast. currently supports AUFS,
                                btrfs, vfs, device mapper
                                </dd>
                                <dt>Container format</dt>
                                <dd>
                                libcontainer is default. In the future will
                                integrate with Solaris Zones, BSD Jails
                                </dd>

                            </dl></aside>
                    </section>

                <!-- Large image slide -->


                </section>

                

                <section>
                  <section>
                    <h2>Images and Containers</h2>

                    <aside class="notes">
                        Understanding how Docker manages the data within your images and containers will help you understand the best way to design your containers and Dockerize your applications, and avoid performance problems along the way
                    </aside>
                  </section>

                  <section>
                    <h3>Docker images</h3>
                    <ul>
                      <li>Images are the basis of containers</li>
                      <li>An image is a <em>readonly</em> file system similar to tar archive</li>
                      <li><em>Distributable</em> artefact of Docker</li>
                      <li class="fragment" data-fragment-index="0">Image must have a name in lower case letters</li>
                      <li class="fragment" data-fragment-index="1">
                        Tag is optional. Implicitly <em>:latest</em> if not specified
                        <ul>
                          <li class="fragment" data-fragment-index="2"><code>postgres<em style="color:green">:9.4</em></code></li>
                          <li class="fragment" data-fragment-index="3"><code>ubuntu == ubuntu<em style="color:green">:latest</em> == ubuntu:<em style="color:green">16.04</em></code></li>
                        </ul>
                      </li>
                      <li class="fragment" data-fragment-index="4">
                        Url and username if pushing to registry
                        <ul>
                          <li class="fragment" data-fragment-index="5"><code><em style="color:green">docker.io</em>/<em style="color:red">username</em>/my-image</code></li>
                          <li class="fragment" data-fragment-index="6"><code><em style="color:green">my.reg.com/</em>my-image:1.2.3</code></li>
                        </ul>
                      </li>
                      


                    </ul>
                  </section>
                  <section>
                    <h3>Types of images</h3>
                    <dl>
                      <dt>Official Base Image</dt> <dd>Images that have no parent (alpine, ubuntu, debian)</dd>
                      <dt>Base Image</dt> <dd>Can be any image (official or otherwise) that is used to build a new image</dd>
                      <dt>Child Images</dt> <dd>Build on base images and add functionality (this is the type you'll build)</dd>
                    </dl>

                  </section>
                  <section>
                      <h3>Layering of images</h3>
                      <ul>
                          <li>Images are <em>layered</em></li>
                          <li>
                              Images always consist of an <em>official base image</em>
                              <ul>
                                  <li>ubuntu:14.04</li>
                                  <li>alpine:latest</li>
                              </ul>
                              <li>Any child image built by adding layers on top of base</li>
                              <li>Each successive layer is set of differences to preceding layer</li>
                          </li>
                      </ul>
                  </section>

                  <section>
                      <h3>Image layers</h3>
                      <img src="img/container-layers.jpg"/>
                  </section>
                  <section>
                      <h3>Sharing image layers</h3>
                      <ul>
                          <li>Images will share any common layers</li>
                          <li>
                              Applies to 
                              <ul>
                                  <li>Images pulled from Docker </li>
                                  <li>Images you build yourself</li>
                              </ul>
                          </li>
                      </ul>
                  </section>
                  <section>
                      <h3>
                          Container basics
                      </h3>
                  </section>
                    <section>
                        <h3>Namespaces</h3>

                        <div style="float:left;width:50%">
                            <ul>
                                <li>Restrict visibility</li>
                                <li>Processes inside a namespace should only see that namespace</li>
                                <li>
                                    Namespaces:
                                    <ul>
                                        <li>pid</li>
                                        <li>mnt</li>
                                        <li>user</li>
                                        <li>ipc</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div style="float:right;width:50%">
                            <img src="img/docker-namespaces.png"
                                 alt="Namespaces"/>
                        </div>

                    </section>
                    <section>
                        <h3>Cgroups</h3>

                        <div style="float:left;width:50%">
                            <ul>
                                <li>Restrict usage</li>
                                <li>Highly flexible; fine tuned</li>
                                <li>
                                    Cgroups:
                                    <ul>
                                        <li>cpu</li>
                                        <li>memory</li>
                                        <li>devices</li>
                                        <li>pids</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div style="float:right;width:50%">
                            <img src="img/cgroups.svg"
                                 alt="cgroups"/>
                        </div>

                    </section>

                    <section>
                        <h3>Combining the two</h3>
                        <p>
                        A running container represents a combination of
                        layered file system,
                        namespace and sets of cgroups
                        </p>
                        <img src="img/namespace-cgroup-combined.svg"
                             alt="Combined namespaces cgroups" />
                    </section>

                  <section>
                      <h3>Container layering</h3>
                      <ul>
                          <li>Container creates its own read/write layer on top of image</li>
                          <li>Multiple containers each have own read/write layer, but can share the actual image</li>
                      </ul>
                      <img src="img/sharing-layers.jpg"/>
                      <aside class="notes">
                          <ul>
                              <li>Difference between containers and images is top writable layer</li>
                              <li>All writes to container stored here</li>
                              <li>Lost when container deleted</li>
                          </ul>
                      </aside>

                  </section>
                    <section>
                      <h3>Behind the scenes</h3>
                      <ul>
                        <li>User types docker commands</li>
                        <li>Docker client contacts docker daemon</li>
                        <li>Docker daemon checks if image exists</li>
                        <li>Docker daemon downloads image from docker registry
                        if it does not exist</li>
                        <li>Docker daemon runs container using image</li>
                      </ul>
                    </section>
                  <section>
                    <h3>Docker architecture</h3>

                    <img src="img/architecture.svg" alt="Architecture">
                    <aside class="notes">
                      <ul>
                        <li>Expalin architecture diagram (Commands and components).</li>
                        <li>Client vs daemon.</li>
                        <li>Union file systems; each command in a Dockerfile creates a new layer in an image.</li>
                        <li>Docker's use of UFS separates it from other container solutions.</li>
                        <li>Execute the "docker run" command and go through the list of steps it does.
                          <ul>
                            <li>Use sudo, unless you are in the Docker group (because of kernel feature permissions)</li>
                            <li>-i for interactive mode, -t for pseudo-tty allocation (Both let you use bash like a terminal)</li>
                          </ul></li>
                          <li>Namespaces => isolation of filesystem and kernel features.</li>
                          <li>Control groups => resource limiting.</li>
                          <li>Different container format avaialble, default is libcontainer</li>
                      </ul></aside>
                    <aside class="notes">
                        <ul>
                            <li>Docker client talks to Docker Daemon</li>
                            <li>Docker Daemon does heavy lifting</li>
                            <li>
                                Client and daemon 
                                <ul>
                                    <li>can run on the same system</li>
                                    <li>communicate using REST API</li>
                                </ul>
                            </li>
                        </ul>
                    </aside>
                    
                  </section>


<section>
                        <h4>Exercise: Create a basic image</h4>
                        <pre><code>$ docker run -t -i ubuntu:16.04 /bin/bash

root@69079aaaaab1:/$ apt-get update 
root@69079aaaaab1:/$ exit

$ docker commit 69079aaaaab1 ubuntu:update
13132d42da3cc40e8d8b4601a7e2f4dbf198e9d72e37e19ee1986c280ffcb97c

$ docker image ls
$ docker diff 69079aaaaab1
$ docker history ubuntu:16.04
$ docker history ubuntu:update</code></pre>
                        <ul>
                            <li>Created a new layer (cache files added by apt)</li>
                            <li>Not an ideal way to create images</li>
                            <li>Better to create images using a Dockerfile</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>If you'd like to keep changes made inside a container, it is possible to save them by committing the container.</li>
                                <li>Commiting creates a new image (ubuntu:update)</li>
                                <li>Now after the running container is stopped, it's possible to run again using ubuntu:update</li>
                            </ul>
                        </aside>

                    </section>

                  <section>
                    <h3>Create images with a <em>Dockerfile</em></h3>
                      <ul>
                          <li>A text file. Usually named <code>Dockerfile</code></li>
                          <li>Sequential instructions for building a Docker image</li>
                          <li>Each instruction creates a layer on the previous</li>
                          <li>A very simple Dockerfile with 4 layers:</li>
                      </ul>
                      
                      <pre><code class="dockerfile">FROM ubuntu:16.04
COPY . /app
RUN make /app
CMD ["python", "/app/app.py"]</code></pre>
                      <aside class="notes">
                          Basically the Dockerfile is like a bash script. It
                          contains instructions for sequentially building an
                          image. Some instructions apply to running the image in a
                          container.
                      </aside>
                      
                  </section>
                  <section>
                    <h3>Structure of a Dockerfile</h3>
                    <ul>
                      <li>Tell Docker which base image to use<pre><code class="dockerfile">FROM ubuntu:15.10</code></pre></li>
                      <li>A number of commands telling docker how to build image
                          <pre><code class="dockerfile">COPY . /app
RUN make /app</code></pre>
                      </li>
                      <li>Optionally tell Docker what command to run when the
                          container is started<pre><code
                                     class="dockerfile">CMD ["python", "/app/app.py"]</code></pre></li>
                          
                    </ul>
                  </section>
                  <section>
                    <h2>Common Dockerfile Instructions</h2>
                    <h3>...a non-exhaustive list</h3>
                  </section>
                  <section>
                    <h4>FROM</h4>
                    <p>Define the base image for a new image</p>
                    <pre><code>FROM ubuntu:17.04</code></pre>

                    <pre><code>FROM debian # :latest implicit</code></pre>

                    <pre><code>FROM my-custom-image:1.2.3</code></pre>
                  </section>
                  <section>

                    <h4>RUN</h4>
                    <pre><code>RUN apt-get update && apt-get install python3</code></pre>
                    <pre><code>RUN mkdir -p /usr/local/myapp && cd /usr/local/myapp</code></pre>
                    <pre><code>RUN make all</code></pre>
                    <pre><code>RUN curl https://domain.com/somebig.tar | tar -xv | /bin/sh</code></pre>
                    <p>Execute shell commands for building image</p>
                  </section>
                  <section>
                    <h4>WORKDIR</h4>
                    <pre><code>WORKDIR /usr/local/myapp</code></pre>
                    <ul>
                      <li>Create a directory to start in when container runs</li>
                      <li>Will be created if does not exist</li>
                    </ul>
                  </section>
                  
                  <section>
                    <h4>COPY</h4>
                    <pre><code>COPY package.json /usr/local/myapp</code></pre>
                    <pre><code>COPY . /usr/share/www</code></pre>
                    <p>Copy files from build directory into image</p>
                  </section>
                  <section>
                    <h4>ENTRYPOINT</h4>
                    <ul style="width:100%">
                        <li class='fragment' data-fragment-index="0">
                         Docker images need not be executable by default 
                        </li>
                      <li class='fragment' data-fragment-index="1">ENTRYPOINT
                          configures executable behaviour of container</li>

                    </ul>
                    <pre class="fragment" data-fragment-index="2"><code>$ cd ~/docker-introduction/sample-code/entrypoint_cmd_examples
$ docker build -t not-executable -f Dockerfile.notexecutable .
$ docker run not-executable # does nothing</code></pre>
                    <ul style="width:100%">
                        <li class="fragment" data-fragment-index="3">
                            Two ways to execute a command:
                                <ul>
                                    <li class='fragment' data-fragment-index="4">
                                shell form: 
                                        <code>ENTRYPOINT </code><code style="color:red;">command</code><code style="color:blue;"> param1 param2 ...</code>
                                    </li>
                                    <li class='fragment' data-fragment-index="5">
                                  exec form: <code>ENTRYPOINT ["command", "param1", "param2"]</code>
                              </li>
                              
                              </ul>
                        </li>
                      

                    </ul>
                    <pre class="fragment" data-fragment-index="5"><code>$ docker build -t executable -f Dockerfile.executable .
$ docker run executable</code></pre>
                    
                  </section>
                  <section>
                    <h4>CMD</h4>
                    <ul style="width:100%;">
                      <li class="fragment" data-fragment-index="0">Provide defaults to executable</li>
                      <li class="fragment" data-fragment-index="1">or provide executable</li>
                      <li class="fragment" data-fragment-index="2"><em>Shell</em> and <em>exec</em> forms just like <code>ENTRYPOINT</code></li>
                      <li class="fragment" data-fragment-index="3">Arguments following the image for <code>docker run image</code> overrides <code>CMD</code></li>
                    </ul>
                    <pre class="fragment" data-fragment-index="4"><code>$ docker build -t cmd-only -f Dockerfile.cmd_only .
$ docker run cmd-only
$ docker run cmd-only echo Good morning, Hal</code></pre>
                  </section>
                  <section>
                    <h4>Combining ENTRYPOINT &amp; CMD</h4>
                    <ul>
                        <li class="fragment" data-fragment-index="0">
                            Use exec form of ENTRYPOINT and CMD together to set base
                            command and default arguments
                        </li>
                        <li class="fragment" data-fragment-index="1">Hypothetical application</li>
                    </ul>
                    <pre class="fragment" data-fragment-index="2"><code>FROM ubuntu:latest
.
.
ENTRYPOINT ["./base-script"]
CMD ["test"]</code></pre>
                    <pre class="fragment" data-fragment-index="3"><code>$ docker run my-image</code></pre>
                    <p class="fragment" data-fragment-index="4">
                    By default this image will just pass <code>test</code> as
                    argument to <code>base-script</code> to run unit tests by
                    default
                    </p>
                    <pre class="fragment" data-fragment-index="5"><code>$ docker run my-image server</code></pre>
                    <p class="fragment" data-fragment-index="6">
                    Passing argument at the end tells it to override CMD and
                    execute with <code>server</code> to run server feature
                    </p>
                  </section>



                  <section>
                    <h3>More Dockerfile instructions </h3>
                    <dl>
                      <dt>EXPOSE        </dt>      <dd>ports to expose when running</dd>
                      <dt>VOLUME        </dt>      <dd>folders to expose when running</dd>
                      <dt>HEALTHCHECK CMD</dt>  <dd>Check container health by running command at regular intervals inside container</dd>
                    </dl>
                  </section>


                  <section>
                    <h3>
                      <code>docker build</code>
                    </h3>
                    <h4>Build Docker images</h4>
                    <code>docker</code> <code style="color:red;">build</code>
                    <code style="color:purple">[options]</code> <code
                    style="color:red;">image[:tag]</code>
                    <code
                    style="color:red;">path</code>


                  <table>
                    <tr>
                      <th>Options</th>
                      <th>Arguments</th>
                      <th>Description</th>
                    </tr>

                    <tr>  <td><code>    --compress             </code></td><td>         </td>       <td>Compress the build context using gzip</td></tr>
                    <tr>  <td><code>-c, --cpu-shares           </code></td><td>  int    </td>         <td>CPU shares (relative weight)</td></tr>
                    <tr>  <td><code>    --cpuset-cpus          </code></td><td>  string </td>        <td>CPUs in which to allow execution (0-3, 0,1)</td></tr>
                    <tr>  <td><code>    --cpuset-mems          </code></td><td>  string </td>        <td>MEMs in which to allow execution (0-3, 0,1)</td></tr>
                    <tr>  <td><code>    --disable-content-trust</code></td><td>         </td>   <td>Skip image verification (default true)</td></tr>
                    <tr>  <td><code>-f, --file string          </code></td><td>         </td>   <td>Name of the Dockerfile (Default is 'PATH/Dockerfile')</td></tr>
                    <tr>  <td><code>    --pull                 </code></td><td>         </td>   <td>Always attempt to pull a newer version of the image</td></tr>
                    <tr>  <td><code>-t, --tag list             </code></td><td>         </td>   <td>Name and optionally a tag in the 'name:tag' format</td></tr>
                  </table>
                  </section>
                  <section>
                      <h4>
                          Exercise: build docker image using Dockerfile
                      </h4>
                      <ul>
                          <li>Call image <code style="color:red;">acme/my-base-image</code></li>
                          <li>Tag it <code style="color:red;">1.0</code></li>
                      </ul>

                      <p>
                      <pre class="fragment" data-fragment-index="0"><code>$ docker build -t acme/my-base-image:1.0  .</code></pre>
                      </p>
<asciinema-player  class="fragment" data-fragment-index="0" autoplay="1"  font-size="medium" speed="3"
    theme="solarized-light" src="lib/build-base-image.json" loop="loop" cols="136" rows="18"></asciinema-player>
                  </section>
                  <!--<section>
                      <h4>Exercise: Build images with common layers</h4>
                      <p>
                      <code>~/docker-introduction/sample-code/layering</code>
                      </p>
                      <p>
                      <code>Dockerfile.base</code>


                      <pre><code class="dockerfile">FROM ubuntu:16.04
COPY . /app</code></pre>
                      </p>

                      <p>
                      <code>Dockerfile</code>


                      <pre><code class="dockerfile">FROM acme/my-base-image:1.0
CMD /app/hello.sh</code></pre>
                      </p>

                      <p>
                      <code>hello.sh</code>

                      <pre><code class="bash">#!/bin/sh
echo "Hello world"</code></pre>
                      </p>

                  </section>-->
                  <section>
                      <h4>Exercise: Build child image</h4>
                      <ul>
                          <li>Create <code style="color:red;">acme/my-final-image</code></li>
                          <li>Tag <code style="color:red">1.0</code></li>
                          <li>Use <code style="color:red">Dockerfile.child</code>
                              to build image</li>
                      </ul>
                      <pre class="fragment" data-fragment-index="0"><code>$ docker build -t acme/my-final-image:1.0 -f Dockerfile.child .</code></pre>
<asciinema-player  class="fragment" data-fragment-index="0" autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/build-child-image.json" cols="136" rows="14"></asciinema-player>
                  </section>
                  <section>
                      <h4>Exercise: Compare base and child image layers</h4>
                      <ul>
                          <li>
                              Use: <code>docker</code> <code style="color:red;">history</code> <code style="color:green;">image</code>
                          </li>
                          <li>The final image should contain all the same layers as the base image </li>
                          <li>One additional layer: the last line of the Dockerfile</li>
                      </ul>
                      <pre><code>$ docker history acme/my-base-image:1.0
$ docker history acme/my-final-image:1.0
IMAGE         ...                                        SIZE 
5932655b26aa  ...   #(nop)  CMD ["/bin/sh" "-c" "/a...   0 B&lt;--new layer
2f723f94263a  ...   #(nop) COPY dir:dd75f285798cdc9...   106 B
8d4c9ae219d0  ...   #(nop)  CMD ["/bin/bash"]            0 B
&lt;missing&gt;     ...   mkdir -p /run/systemd && echo '...   7 B
&lt;missing&gt;     ...   sed -i 's/^#\s*\(deb.*universe\...   2.78 kB
&lt;missing&gt;     ...   rm -rf /var/lib/apt/lists/*          0 B
&lt;missing&gt;     ...   set -xe   && echo '#!/bin/sh' >...   745 B
&lt;missing&gt;     ...   #(nop) ADD file:9e2eabb7b05f940...   106 MB
                      </code></pre>
                  </section>


                  <!--<section>
                    <h3>Images and Tags</h3>
                    <ul>
                      <li>Tags specify a particular version of an image<pre><code>$ docker pull ubuntu:14.04</code></pre></li>
                      <li>Default to <em>latest</em>. In most cases this is a LTS version<pre><code>$ docker pull ubuntu</code></pre></li>
                        <li>Registries like Docker Hub contain >> 100K images<pre><code>$ docker search ubuntu</code></pre></li>

                    </ul>
                  </section>-->
                  


                </section>
                <section>
                    <section>
                        <h2>Dockerising applications</h2>
                    </section>
                  <section>
                    <h3>Create web application in Docker </h3>
                    <ul>
                      <li>Create a small web app based on Python Flask</li>
                      <li>Write a Dockerfile</li>
                      <li>Build an image</li>
                      <li>Run the image</li>
                      <li>Upload image to a Docker registry</li>
                    </ul>
                  </section>
                  <section>
                    <h3>Step 1. Set up the web app</h3>
                    <ul>
                      <li>Under <code>~/docker-introduction/sample-code/flask-app</code>
                        <dl>
                          <dt>app.py</dt> <dd>A simple flask application for displaying cat pictures</dd>
                          <dt>requirements.txt</dt> <dd>list of dependencies for flask</dd>
                          <dt>templates/index.html</dt> <dd>A jinja2 template</dd>
                          <dt>Dockerfile</dt><dd>Instructions for building a Docker image</dd>
                        </dl>
                      </li>
                    </ul>

                  </section>



                  <section>
                      <h3>Our Dockerfile</h3>
                    <pre><code>FROM alpine:3.5

# Install python and pip
RUN apk add --update py2-pip

# install Python modules needed by the Python app
COPY requirements.txt /usr/src/app/
RUN pip install --no-cache-dir -r /usr/src/app/requirements.txt

# copy files required for the app to run
COPY app.py /usr/src/app/
COPY templates/index.html /usr/src/app/templates/

# tell the port number the container should expose
EXPOSE 5000

CMD ["python", "/usr/src/app/app.py"]</code></pre>
                  </section>

                  <section>
                    <h3>
                      Build the Docker image
                    </h3>
                    <pre><code>$ cd ~/docker-introduction/sample-code/flask-app 
$ docker build -t YOURNAME/myfirstapp .</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119506.json" cols="174" rows="22"></asciinema-player>
<p>
Note: please replace YOURNAME with your Docker Hub username
</p>
                  </section>

                  <section>
                    <h3>
                      Run the container
                    </h3>
                    <pre><code>$ docker run -p 8888:5000 --name myfirstapp YOURNAME/myfirstapp</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119510.json" cols="174" rows="11"></asciinema-player>
                    ...Now open <a href="http://localhost:8888">your test webapp</a>
                  </section>


                  <section>
                      <h3>Login to a registry</h3>

                      <pre><code>$ docker login &lt;registry url&gt;</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-120558.json" cols="138" rows="11"></asciinema-player>
<ul>

  <li>If registry not specified, logs into <a href="https://hub.docker.com">hub.docker.com</a></li>
  <li>Can log in to multiple registries</li>

</ul>
                  </section>

                  <section>
                    <h3>
                      Push image to registry
                    </h3>
                    <pre><code>$ docker push YOURNAME/myfirstapp</code></pre>

<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119547.json" cols="174" rows="12"></asciinema-player>
                  </section>




                  <section>
                    <h3>Summary</h3>
                    <ul>
                      <li>Wrote a small web application</li>
                      <li>Used Dockerfile to create an image</li>
                      <li>Pushed image to upstream registry</li>
                    </ul>
                    <aside class="notes">
                      <ul>
                        <li>Docker allowed us to create and test an app on an arbitrary OS without physical hardware</li>
                        <li>Create an artefact which we can share with coworkers, test and deploy</li>
                      </ul>
                    </aside>
                  </section>


                  <!-- Large image slide -->
                </section>
                <section>
                    <section>
                        <h2>Dockerfile best practices</h2>
                    </section>

                    <section>
                        <h3>General guidelines</h3>
                        <ul>
                            <li>Containers should be as ephemeral as possible</li>
                            <li>Use a <code>.dockerignore</code> file</li>
                            <li>Avoid installing unnecessary packages</li>
                            <li>Minimise concerns <ul><li>Avoid multiple processes/apps in one container</li></ul></li>
                        </ul>
                        <aside class="notes">
                            <ul><li>
                                    By ephemeral is meant that a container can be built, stopped, destroyed and rebuilt with minimal setup and configuration
                                </li>
                                <li>dockerignore to avoid copying in unneeded stuff (.git subdirectory)</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>General guidelines</h3>
                        <ul>
                            <li>Use current official repositories in FROM as base image
								<ul>
									<li>debian 124 MB</li>
									<li>ubuntu 117 MB</li>
									<li>alpine 3.99 MB</li>
									<li>busybox 1.11 MB</li>
								</ul>
</li>
                            <li>Minimise Layers</li>
                            <li>Sort multiline arguments</li>
                            <li>Split complex RUN statement on separate lines with backslashes</li>
                            <li>Run apt-get update and apt-get install in same RUN </li>
                            <li>Run clean up in same line whenever possible</li>
                        </ul>

                    </section>

                    <section>
                      <h3>Layer caching</h3>
                      <pre><code>$ cd ~/docker-introduction/sample-code/caching
$ docker build -t caching-example -f Dockerfile.layering . </code></pre>
                      <ul>
                        <li class="fragment" data-fragment-index="0">Build image in <code>sample-code/caching</code> directory</li>
                        <li class="fragment" data-fragment-index="1">Run build a second time. What happens?</li>
<li class="fragment" data-fragment-index="2" >Change line with Change me! and run again</li>
                        <li class="fragment" data-fragment-index="3">Each instruction creates a layer in an image</li>
                        <li class="fragment" data-fragment-index="4">Docker caches layers when building</li>
                        <li class="fragment" data-fragment-index="5">When a layer is changed Docker rebuilds from changed layer</li>
                      </ul>

                      
                    </section>
                    
                    <section>
                        <h3>Consequences of layer caching</h3>
                        <div style="width:100%">
                            <div style="float:left;width:50%">
                                <pre><code class="dockerfile"># Example 1
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y curl
#RUN apt-get install -y nginx</code></pre>

                            </div>
                            <div style="float:left;width:50%">
                                <pre><code class="dockerfile"># Example 2
FROM ubuntu:latest
RUN apt-get update \
  && apt-get install -y curl #nginx</code></pre>
                            </div>
                        </div>
                        <div style="width:100%;float:left" class="fragment"
                            data-fragment-index="0" >
                            <pre><code>$ cd ~/docker-introduction/sample-code/caching
$ docker build  -t bad-apt-example -f Dockerfile.bad .
$ docker build  -t good-apt-example -f Dockerfile.good .
                            </code></pre>
                        </div>
                        <ul>
                            <li class="fragment"
                                data-fragment-index="1">Uncomment nginx line
                                and run <code>docker build</code> again</li>
                            <li class="fragment" data-fragment-index="2">Only rebuilds from layer that was <em>changed</em></li>
                            <li class="fragment"
                                data-fragment-index="3">Example 1: <code>apt-get update</code> does not refresh index
                                <ul>
                                    <li>apt repos might change</li>
                                </ul>
                                <li class="fragment" data-fragment-index="4">
                                    Best to combine apt-get update and install
                                    packages to force apt to refresh index
                                    (Example 2)
                                </li>
                            </li>
                        </ul>
                        
                    </section>

                    <section>
                        <h3>
                            Minimise Layers
                        </h3>
                        <p>
                        Remove non-essential files when possible.
                        </p>

                        <div style="width:50%;float:left">
                        <p>Image size: 471 MB</p>
                            <pre><code>FROM ubuntu:latest

RUN apt-get update \ 
 && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro</code></pre>
                        </div>
                        

                        <div style="float:left;width:50%">
                            <p>Image size: 430 MB</p>
                            <pre><code>FROM ubuntu:latest

RUN apt-get update \
  && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
&& rm -rf /var/lib/apt/lists/*</code></pre>
                        </div>
                    </section>
                    
                    <section>
                        <h3>ADD</h3>
                        <ul style="width:80%">
                            <li class="fragment" data-fragment-index="0">Copies files to a directory
                                <pre><code>ADD . /usr/path/</code></pre>
                            </li>
                            <li class="fragment" data-fragment-index="1">Downloads file from web <pre><code>ADD http://domain.com/file.txt /usr/path/</code></pre></li>
                            <li class="fragment"
                                data-fragment-index="2">Unpack archives into
                                directory<pre><code>ADD file.tar /usr/path/ </code></pre></li>
                            <li class="fragment"
                                data-fragment-index="3">However, does not
                                unpack remote archives. This will just put
                                <code>file.tar</code> in
                                <code>/usr/path/</code><pre><code>ADD http://domain.com/file.tar /usr/path/ </code></pre></li>
                        </ul>
                    </section>
                    
                    <section>
                        <h3>ADD vs COPY</h3>
                        
                        <ul style="width:100%">
                            <li class="fragment" data-fragment-index="0">Problem with ADD <pre><code>ADD http://domain.com/big.tar.gz /usr/path/ # large intermediate layer
RUN cd /usr/path && tar -xvf big.tar.gz \
   && rm big.tar.gz</code></pre> 
                                <ul><li>Increased overall image size</li></ul></li>
                            <li class="fragment" data-fragment-index="1">Better solution:
                                <pre><code>RUN curl -SL http://domain.com/big.tar.gz  \ 
   | tar -xJC /usr/path</code></pre>
                            <ul class="fragment" data-fragment-index="2"><li>Smaller image size</li></ul>
                            </li>
                            <li class="fragment" data-fragment-index="3">COPY only copies files <pre><code>COPY . /usr/path/</code></pre></li>
                            <li class="fragment" data-fragment-index="4">Recommend to only use COPY and never ADD</li>
                        </ul>
                    </section>
                    
                    <section>
                        <h3>
                            CMD &amp; ENTRYPOINT
                        </h3>
                        <h4>
                            General best practices
                        </h4>
                        <ul                             style="width:100;">
                            <li class="fragment" data-fragment-index="0"
>Avoid using <em>shell</em> form
                                <ul><li><code>ENTRYPOINT "executable param1 param2 ..."</code></li></ul></li>
                            <li class="fragment" data-fragment-index="1"
>
                                Docker directs POSIX commands at process with PID
                                1
                            </li>
                            <li class="fragment" data-fragment-index="2"
>
                                Using <em>shell</em> form, process is run internally using <code>/bin/sh
                                    -c</code> and do not have PID 1
                            </li>
                            <li class="fragment" data-fragment-index="3"
>
                                It can be difficult to stop container since
                                process does not receive SIGTERM from <code>docker stop container</code>
                            </li>
                            
                        </ul>
                        <pre class="fragment" data-fragment-index="4"><code>$ cd ~/docker-introduction/sample-code/entrypoint_cmd_examples
$ docker build -t runtop-shell -f Dockerfile.top_shell .
$ docker run --rm --name topshell runtop-shell</code></pre>
                        <p class="fragment" data-fragment-index="5">
                        What happens when you want to stop container
                        <em>topshell</em>?
                        </p>
                    </section>
                    <section>
                        <h3>
                            CMD &amp; ENTRYPOINT
                        </h3>
                        <h4>
                            General best practices
                        </h4>
                        <ul class="fragment" data-fragment-index="1"
                            style="width:100;">
                            <li>Best practice to run in <strong>exec</strong> form: <ul><li><code>CMD ["executable", "param1", "param2", ..]</code></li></ul></li>
                            <li>Or in form that creates interactive shell like
                                <ul><li><code>ENTRYPOINT ["python"]</code></li><li><code>CMD ["/bin/bash"]</code></li></ul></li>
                        </ul>
                        <pre class="fragment" data-fragment-index="3"><code>$ docker build -t runtop -f Dockerfile.top .
$ docker run runtop</code></pre>
                    </section>
                    <!--<section>
                        <h3>ENTRYPOINT</h3>
                        <pre><code class="dockerfile">ENTRYPOINT ["python", "manage.py"]
CMD ["test"]</code></pre>
                        <ul>
                            <li>When used in conjunction with CMD:
                                <ul><li>Set base command with ENTRYPOINT</li>
                                    <li>Use CMD to set default argument</li> </ul></li> 
                            <li>Will just run tests when container is run with no params <ul><li><code>docker run myimage</code></li></ul></li>
                            <li>Can override by passing argument to container
                                <ul><li><code>docker run myimage runserver</code></li></ul></li>
                            <li>For more see <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Dockerfile Best practices</a></li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Use CMD when you want the user to have the choice of commands to run</li>
                                <li>Use ENTRYPOINT when you want to wrap a command</li>
                                <li>ENTRYPOINT can be overridden with the --entrypoint flag</li>
                            </ul>
                        </aside>
                    </section>-->

                </section>

                <!--<section>
                <section>
                    <h3>Microservices</h3>
                    <p>Cockcrofts definition: Loosely coupled service oriented architecture with bounded contexts</p>
                    <p>Eric Brewers: Microservice boundaries are language boundaries and team boundaries</p>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>A suite of small services, each running in its own process and communicating with lightweight mechanisms</li>
                        <li>Services can be implemented with entirely different stacks</li>
                        <li>Services can be developed, maintained, and updated independently</li>
                        <li>Often use well defined REST APIs to communicate</li>
                        <li>If a message bus/queue is used then its likely to be lightweight (ZeroMQ vs ESB)</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>Often use a DevOps approach (you build it you run it)</li>
                        <li>Smart endpoints and dumb pipes</li>
                        <li>Decentralized Data Management with eventual consistency</li>
                        <li>Continuous integration and delivery</li>
                        <li>Design for failure (optimize MTTR (mean-time-to-repair))</li>
                    </ul>
                    <aside class="notes">Smart endpoints and dumb pipes: Communication mediums should be as simple/dumb as possible (e.g. simple message queue, REST); the logic should be in the app.</aside>
                </section>
                <section>
                    <h3><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></h3>
                    <ul>
                        <li>Create a Separate Data Store for Each Microservice</li>
                        <li>Keep Code at a Similar Level of Maturity</li>
                        <li>Do a Separate Build for Each Microservice</li>
                        <li>Deploy in Containers</li>
                        <li>Treat Servers as Stateless</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Separate data stores: Use the best DBMS and schema for each service.</li>
                      <li>When doing new development, create a new microservice, rather than extending the existing one (so that you don't break it or make it less performant). You can merge the microservices later if needed.</li>
                      <li>Stateless: Cattle, not pets.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Containers and Microservices</h3>
                    <ul>
                        <li>Containers do not necessarily map to service or application boundaries</li>
                        <li>A service will often contain more than one container</li>
                        <li>A container is more like an OO Class - Brendan Burns @ Dockercon 2015</li>
                        <li>A container is a persistent object - Eric Brewer @ OSCon 2015</li>
                    </ul>
                    <aside class="notes">Containers are great for microservices, because they simplify the task of deploying many individual services, each with their own requirements.</aside>
                </section>
                <section>
                    <h3>Containers and Microservices: Requirements</h3>
                    <ul>
                        <li>Sharing among containers (eg filesystems)</li>
                        <li>Atomic co-scheduling of containers</li>
                        <li>Parameterization of containers</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Volumes</li>
                      <li>Being able to spin up a bunch of containers together as a unit.</li>
                      <li>Parameters through environment variables for different environments.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices - Resources</h3>
                    <ul>
                        <li><a href="http://martinfowler.com/articles/microservices.html">Microservices - Martin Fowler</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Adopting Microservices at Netflix: Lessons for Architectural Design</a></li>
                        <li><a href="https://www.nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/">Adopting Microservices at Netflix: Lessons for Team and Process Design</a></li>
                        <li><a href="https://www.youtube.com/watch?v=e4jr6Ihz4Qo">Kubernetes: The Path to Cloud Native - Eric Brewer - OSCon 2105</a></li>
                        <li>Nginx blog Building Microservices series: <a href="https://www.nginx.com/blog/introduction-to-microservices/">1</a>,<a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">2</a>,<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">3</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></li>
                    </ul>
                </section>
                </section>-->
                <section>
                  <section>
                    <h2>Docker and Development</h2>
                  </section>

                <section>
                    <h3>Microservices vs. Monoliths</h3>
                    <div style="float:left;width:50%">
                      <ul>
                        <li>Small decoupled applications vs. one big app</li>
                        <li>Developed independently</li>
                        <li>Deployed and updated independently</li>
                        <li>Scaled independently</li>
                        <li>Better modularity</li>
                        <li class="fragment" data-fragment-index="0">Docker containers fit with microservice architecture</li>

                      </ul>
                    </div>
                    <div style="float:left;width:50%">
                      <img src="img/microservice-basic.png" />
                    </div>
                    <aside class="notes"><ul>
                        <li>
                          Compare to a monolith application which has grown with
                          time
                        </li>
                      <li><a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></li>
                    </ul></aside>
                </section>



                  <section>
                      <h3>Example voting application</h3>
                    <h4>Microservice application consisting of 5 components</h4>
                              <div style="width:50%;float:left">
                                <ul>

                                  <li class="fragment" data-fragment-index="0">Python web application</li>
                                  <li class="fragment" data-fragment-index="1">Redis queue</li>
                                  <li class="fragment" data-fragment-index="2">.NET worker</li>
                                  <li class="fragment" data-fragment-index="3">Postgres DB with a data volume</li>
                                  <li class="fragment" data-fragment-index="4">Node.js app to show votes in real time</li>
                                </ul>
                              </div>
                              <div style="float:left;width:50%">
                                <img src="img/voting-app.png" alt="Voting application"/>
                              </div>
                              <div style="float:left;width:100%;">
                                  <pre class="fragment" data-fragment-index="5"><code>$ git clone https://github.com/dockersamples/example-voting-app.git
$ cd example-voting-app</code></pre>
                              </div>
                  </section>

                  <section>
                    <h3>
                      Build vote app components
                    </h3>
                    <pre class="fragment" data-fragment-index="0"><code>$ docker build -t vote vote</code></pre>
                    <pre class="fragment" data-fragment-index="1"><code>$ docker build -t result result</code></pre>
                    <pre class="fragment" data-fragment-index="2"><code>$ docker build -t worker worker</code></pre>
                    <pre class="fragment" data-fragment-index="3"><code>$ docker image ls</code></pre>
                  </section>
                  
                  <section>
                      <h3>Run microservices</h3>

                      <!--<div style="width:20%;float:left;"><ul>
                              <li class="fragment" data-fragment-index="0">Run flask app 
                                  
                                  <ul>
                                      <li class="fragment" data-fragment-index="1">
                                          <code>--link</code> to connect redis and db to vote container
                                      </li>
                                  </ul>

                              </li>
                              <li class="fragment" data-fragment-index="2">
                                  Results app
                                  
                                  <ul>
                                      <li class="fragment" data-fragment-index="3"><code>-v</code> to mount directory as volume</li>
                                      <li class="fragment" data-fragment-index="4"><code>-p</code> to map ports in docker container</li>
                                  </ul>
                              </li>
                              <li class="fragment" data-fragment-index="5">
                                  Worker app
                              </li>

                          </ul></div>-->
                          <div >
                              <pre><code>#! /bin/bash
# Helper services
docker run --rm -d -p 6379:6379 --name redis redis:alpine
docker run --rm -d --name db postgres:9.4 

# Application
docker run --rm -d --name vote --link redis \
    --link db -v $PWD/vote:/app  -p 5000:80 vote

docker run --rm -d --name worker --link redis --link db worker

docker run --rm -d --name result -v $PWD/result:/app \
   --link db -p 5001:80 -p 5858:5858 result nodemon --debug server.js</code></pre>                  
                          </div>
                          <dl>
                              <dt><code>--link a:b</code></dt>   <dd>Link container <em>a</em> to container <em>b</em></dd>
                              <dt><code>-v  ./path:/var/lib/path</code></dt>   <dd>Mount a directory as a volume</dd>
                              <dt><code>-p  8080:80 </code></dt>   <dd>Map port in container</dd>
                          </dl>
                  </section>
                  <section>
                    <h3>Disadvantages of this approach</h3>
                    <ul>
                      <li>Complicated with shell/script commands
                          <ul>
                              <li>Managing service interactions</li>
                              <li>Adding/managing services</li>
                          </ul>
                      </li>
                      <li>Can't scale services</li>
                      <li>Stopping services is P.I.T.A.</li>
                      <li>Better tools exist..</li>
                    </ul>
                  </section>
                <section>
                    <h3>Docker Compose</h3>
                    <h4>Docker as a dev environment</h4>
                    <div style="width:50%;float:left;">
                        <ul>
                            <li class="fragment"
                                data-fragment-index="0">Declarative YAML syntax</li>
                          <li class="fragment" data-fragment-index="1">Specifies
                            <ul>
                              <li>Services</li>
                              <li>image or build</li> 
                              <li>volumes</li>
                              <li>environment variables</li>
                            </ul>
                          </li> 
                            <li class="fragment"
                                data-fragment-index="2">Interactive
                                development</li>
                            <li class="fragment" data-fragment-index="3">Can be used for staging/production environments</li>
                        </ul>
                    </div>
                    <div class="fragment" data-fragment-index="0" style="width:50%;float:left;">
                    <pre><code>---
# docker-compose.yml
version: '3'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
      - logvolume01:/var/log
    links:
      - redis
  redis:
    image: redis
    volumes:
      logvolume01: {}</code></pre>
                    </div>
                </section>

                <section>
                    <h3>Docker Compose</h3>
                    <h4>Basic commands</h4>
                    <p>
                    <code>docker-compose</code> <code style="color:red;">COMMAND</code> <code style="color:blue;">[options]</code> <code>[args]</code>
                    </p>

                    <table>
                        <tr>
                            <th>Command</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code >up</code></td>
                            <td>Start compose</td>      
                        </tr>
                        <tr>
                            <td>
                                 <code >down</code>
                            </td>
                            <td>
                                Stop &amp; tear down containers/networks
                            </td>
                        </tr>
                        <tr>
                            <td>
                                 <code >restart</code> &lt;service name&gt;
                            </td>
                            <td>
                                Restart a service
                            </td>
                        </tr>
                        scale
                        
                    </table>
                    
                    <p class="fragment" data-fragment-index="0">Use
                    <code>docker-compose</code> <code
                    style="color:red;">-h</code> to view inline documentation</p>
                    <p class="fragment" data-fragment-index="1">Have a look at
                    the <a href="">documentation</a></p>

                </section>
                <section>
                    <h3>Docker Compose Example</h3>
                    <pre><code>$ cd example-voting-app
$ docker-compose up -d</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/docker-compose.json" cols="174" rows="15"></asciinema-player>
<p class="fragment" data-fragment-index="0">
 <a href="http://localhost:5000">Vote</a> and <a href="http://localhost:5001">view results</a>
</p>
                </section>
                
                  <section>
                      <h3>Interactive development</h3>
                      <ul>
                          <li>Open up <code>vote/app.py</code> </li>
                          <li>On lines 8 & 9, modify vote options</li>
                          <li>View change in <a href="http://localhost:5000">voting</a> application</li>
                      </ul>
                  </section>
                  <section>
                      <h3>Change vote options</h3>
 <asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-120556.json" cols="138" rows="21"></asciinema-player>
                  </section>
                  <section>
                      <h3>Scaling services</h3>
                      <pre><code>$ docker-compose up -d --scale SERVICE=&lt;number&gt;</code></pre>
 <asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
     theme="solarized-light" src="lib/docker-compose-scaling-service.json" cols="138" rows="21"></asciinema-player>

                  </section>
                </section>  


                <section>
                  <section>
                    <h2>Container Orchestration</h2>
                  </section>

                <section>
                    <h3>First, some more buzzwords</h3>
                    <ul>
                        <li><a href="http://radar.oreilly.com/2015/06/an-introduction-to-immutable-infrastructure.html">Immutable infrastructure</a></li>
                        <li><a href="https://blog.engineyard.com/2014/pets-vs-cattle">Cattle vs pets</a></li>
                        <li><a href="http://martinfowler.com/bliki/SnowflakeServer.html">Snowflake Servers</a> vs. <a href="http://martinfowler.com/bliki/PhoenixServer.html">Phoenix Servers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Immutable architecture: Instead of mutating an instance, replace it with a new one.</li>
                      <li>Pets (nursed back to health) vs. Cattle (replaced when sick)</li>
                      <li>Snowflake (unique) vs. Phoenix (constantly rising from the ashes of its predecessor)</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>Immutable Architecture/Infrastructure</h3>
                    <div style="float:left;width:50%"><ul>
                        <li>Phoenix servers</li>
                        <li>The environment is defined in code</li>
                        <li>If you need to change <em>anything</em> you create a new instance and destroy the old one</li>
                        <li>Docker makes it much more likely you will work in this way</li>
                      </ul></div>
                    <div style="float:left;width:50%"><img src="img/immutable_infrastructure.gif" alt="Immutable Architecture" ></div>
                    <aside class="notes">Docker basically forces you to not manually alter servers.</aside>
                </section>
                <!-- Large image slide -->
                
                  <section>
                    <h3>
                      Container orchestration 
                    </h3>
                    <ul>
                      <li>Frameworks for container orchestration
                        <ul>
                          <li>Docker Swarm</li>
                          <li>Kubernetes</li>
                        </ul>
                      </li>
                      <li>Manage deployment/restarting containers across clusters</li>
                      <li>Networking between containers (microservices)</li>
                      <li>Scaling microservices</li>
                      <li>Fault tolerance</li>
                      

                    </ul>
                  </section>
                <section>
                    <h3>Kubernetes</h3>
                    <ul>
                        <li>Container orchestrator</li>
                        <li>Started by Google</li>
                        <li>Inspired by Borg (Google's cluster management system)</li>
                        <li>Open source project written in Go</li>
                        <li>Cloud Native Computing Foundation</li>
                        <li>Manage applications not machines</li>
                    </ul>
                </section>
                <section>
                  <h3>Kubernetes Overview</h3>
                  <img src="img/kubernetes-diagram.png" alt="Kubernetes diagram">
                  <aside class="notes">The services and controllers actually run as processes on every node. The external load balancer is necessary to split traffic across the nodes, and once it reaches a node, the service will route it to the correct pod, or even a different node (see: http://www.dasblinkenlichten.com/kubernetes-101-external-access-into-the-cluster/).</aside>
                </section>
                <section>
                    <h3>Kubernetes Components</h3>
                    <ul>
                        <li>Pods - an ephemeral group of co-scheduled containers that together provide a service</li>
                        <li>Flat Networking Space - each pod has an IP and can talk to other pods, within a pod containers communicate via localhost (need to manage ports)</li>
                        <li>Labels - Key value pairs, used to label pods and other objects so the scheduler can operate on them</li>
                        <li>Services - stable endpoints comprised of one or more pods (external services are supported)</li>
                        <li>Replication Controllers - the orchestrator that controls and monitors the pods within a service (known as replicas)</li>
                    </ul>
                </section>
                <!--<section>
                    <h3>Pods/Services</h3>
                    <ul>
                        <li>Co-locate containers</li>
                        <li>Shared volumes</li>
                        <li>IP address (important for port space and migration)</li>
                        <li>Unit of deployment and migration</li>
                        <li>Easy migration = high utilisation</li>
                        <li>Scale service by scaling pods</li>
                    </ul>
                </section>-->
                  <section>
                      <h3>Docker Swarm</h3>
                      <div style="float:left;width:50%"><ul>
                          <li>Standard since Docker 1.12</li>
                          <li>Manage containers across multiple machines
                            <ul>
                              <li>Scaling services</li>
                              <li>Healthchecks</li>
                              <li>Load balancing</li>
                            </ul>
                          </li>
                        </ul></div>
                        <div style="float:left;width:50%">
                          <img src="img/dockerswarm.png" alt="Docker swarm"/>
                        </div>
                  </section>
                  <section>
                    <h3>Docker Swarm</h3>
                    <ul>
                      <li>Two types of machines or <em>nodes</em>
                        <ul>
                          <li>1 or more <em>manager</em> nodes</li>
                          <li>0 or more <em>worker</em> nodes</li>
                        </ul>
                      </li>
                      <li>Managers control global state of cluster</li>
                        <ul>
                          <li>Raft Consensus Algorithm</li>
                          <li>If one manager fails, any other should take over
                        </ul>
                      </li>
                      
                    </ul>
                  </section>
                  <section>

                    <img src="img/voting-app-swarm.png" alt="Docker swarm"/>
                  </section>
                  <section>
                      <h3>Swarm Stack File</h3>
                      <div style="float:left;width:50%"><ul>
                          <li>Similar to file used for <code>docker-compose</code></li>
                          <li>
                              A few differences
                              <ul>
                                  <li>No <code>build</code> option</li>
                                  <li>No shared volumes</li>
                              </ul>
                          </li>

                        </ul></div>
   <div style="float:left;width:50%;height:80%"><pre><code class="yaml"># stack.yml
version: "3.3" 
services:
  db:
    image: postgres:9.4
    .
    .
  redis:
    image: redis:latest
    deploy:
      replicas: 3

  vote:
    image: vote:latest
    depends_on:
      - redis
      - db
     deploy:
      replicas: 6
      update_config:
         delay: 5s
         parallelism: 1
    .
    .</code></pre></div>                  
                  </section>
                  
                  <section>
                      <h3>Initiate a Swarm</h3>
                      <pre><code>$ docker swarm init
$ cd ~/example-voting-app</code></pre>
                      <ul>
                          <li><code>docker swarm init</code> puts your machine in <em>swarm mode</em></li>
                          <li>Only need to do once to create manager node</li>
                      </ul>
                  </section>

                  <section>
                      <h3>Deploy the stack</h3>
                      <pre><code>$ docker stack deploy --compose-file docker-stack.yml vote</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119595.json" cols="174" rows="15"></asciinema-player>
                  </section>

                  <section>
                      <h3>Verify stack is running</h3>
                      <pre style="width:100%"><code>$ watch docker stack ps vote</code></pre>
 <asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-119596.json" cols="174" rows="15"></asciinema-player>
Now, let's go <a href="http://localhost:5000">vote</a>! When you're done, have
a look at the <a href="http://localhost:5001">results</a>.
                  </section>

                  <section>
                      <h3>Build image</h3>
                      <p>
                      In example-voting-app...
                      </p>

                      <pre><code>$ docker build -t vote:v2 vote</code></pre>
                      <p>Note: please replace <code>yourname</code> with your docker hub
                      username if you have one</p>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-120557.json" cols="138"
    rows="15"></asciinema-player>
                  </section>

                  

                    <section>
                        <h3>Update a service</h3>
                        <pre><code>$ docker service update --image vote:v2 vote_vote</code></pre>
<p>
Now go to the <a href="http://localhost:5000">voting app</a> and see what
changed
</p>
                    </section>

                    <section>
                        <h3>Remove Swarm Stack</h3>
                        <pre><code>$ docker stack rm vote</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-120569.json" cols="130"
    rows="15"></asciinema-player>
                    </section>
                  <section>
                      <h3>Summary</h3>
                      <ul>
                          <li>Deployed a set of services on our local host</li>
                          <li>Docker created a couple networks (front-tier, back-tier)</li>
                          <li>Some services running multiple instances</li>
                          <li>Next, we'll look at doing this across multiple machines</li>
                      </ul>
                  </section>

                </section>

                <section>
                    <section>
                        <h2>Running apps in the cloud</h2>
                    </section>

                  <section>
                    <h3>Goals</h3>
                    <ul>
                      <li class="fragment" data-fragment-index="0">Set up cluster of multiple machines
                      <ul><li>Catalyst Cloud (OpenStack)</li></ul></li>
                      <li class="fragment" data-fragment-index="1">Install
                        Docker on each machine </li>
                      <li class="fragment" data-fragment-index="2">Initialise a swarm</li>
                      <li class="fragment" data-fragment-index="3">Deploy our voting app</li>
                       <li class="fragment" data-fragment-index="4">Run through a few typical scenarios
                           <ul>
                               <li>Rolling update with <em>vote:v2</em></li>
                               <li>Drain node for maintenance</li>
                           </ul>
                       </li> 
                    </ul>
                  </section>
                  <section>
                    <h3>Setting up cluster</h3>
                    <div style="float:left;width:50%">
                        <ul>
                            <li class="fragment" data-fragment-index="0">
                                Need to:
                                <ul>

                                  <li>provision machines</li>
                                    <li>set up router(s)</li>
                                    <li>set up security groups</li>
                                </ul>
                            </li>
                            <li class="fragment" data-fragment-index="1">
                                Preferable to use automation tools:
                                <ul>
                                    <li>Chef</li>
                                    <li>Puppet</li>
                                    <li>Terraform</li>
                                    <li>Ansible</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div style="width:50%;float:left">
                        <img  class="fragment"
                        data-fragment-index="0"src="img/open-stack-swarm.png" />
                    </div>

                  </section>
                    <!--<section>
                        <h3>Ansible</h3>
                        <ul>
                            <li>Python based tool set</li>
                            <li>Automate devops tasks
                                <ul>
                                    <li>server/cluster management </li>
                                    <li>installing packages</li>
                                    <li>deploying code </li>
                                    <li>managing config</li>
                                </ul>
                        </ul>
                        </section>        -->
                    
                    <!--<section>
                        <h3>Setup steps</h3>
                        <pre class="fragment" data-fragment-index="0"><code>$ cd ~/catalystcloud-ansible
$ ./install-ansible.sh
.
.
$ source $CC_ANSIBLE_DIR/ansible-venv/bin/activate</code></pre>
                        <pre class="fragment" data-fragment-index="1"><code>$ source ~/os-training.catalyst.net.nz-openrc.sh</code></pre>
                        <ul class="fragment" data-fragment-index="2">
                            <li>Should have ansible installed</li>
                            <li>Should have activated and sourced a python virtualenv <ul><li><code>(ansible-env)</code> should appear at beginning of line in your shell</li></ul> </li>
                            <li>Sourced the environment file for the training account</li>
                        </ul>
                    </section>-->

                    <section>
                        <h3>Create a cluster</h3>
                        <pre><code>$ cd ~/catalystcloud-ansible/example-playbooks/docker-swarm-mode
$ ansible-playbook --ask-sudo-pass \
    --extra-vars "suffix=-$( hostname )" \
    create-swarm-hosts.yaml</code></pre>
                    </section>

                    <section>
                        <h3>Create Swarm</h3>

                         <pre><code>$ ssh manager&lt;TAB&gt;&lt;ENTER&gt;
$ docker swarm init</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-120530.json" cols="107" rows="12"></asciinema-player>

<p>
Copy the <code>docker swarm join ...</code> command that is output
</p>




                    </section>
                    <section>
                        <h3>Join Worker Nodes</h3>
                        <p>
                        Paste the command from the manager node onto command
                        line.
                        </p>

                        <pre><code>$ ssh worker1&lt;TAB&gt;&lt;ENTER&gt;
$ docker swarm join --token $TOKEN  192.168.99.100:2377</code></pre>
 <asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1" theme="solarized-light" src="lib/asciicast-120531.json" cols="107" rows="10"></asciinema-player>
<p>Repeat this for <code>worker2</code></p>
                    </section>

                    <section>
                        <h3>Check nodes</h3>
                        <pre><code>$ docker node ls</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-120532.json" cols="107" rows="6"></asciinema-player>
                    </section>

                    <section>
                        <h3>Deploying voting app</h3>
                        <p>
                        Upload docker-stack.yaml to manager node
                        </p>
                        <pre><code>$ cd ~/example-voting-app
$ scp docker-stack.yml manager1-TRAININGPC:~/</code></pre>
                    </section>
                    <section>
                        <h3>Deploy application</h3>
                        <pre><code>$ docker stack deploy -c docker-stack.yml vote</code></pre>
<script  data-autoplay="1" data-loop="1" data-size="small" data-speed="1" type="text/javascript" src="https://asciinema.org/a/120533.js" id="asciicast-120533" async></script>
                    </section>
                    <section>
                        <h3>Monitor deploy progress</h3>
                        <pre><code>$ watch docker stack ps vote</code></pre>
                        <pre><code>$ watch docker service ls</code></pre>
                    </section>
                    <section>
                        <h3>Try out the voting app</h3>
                        <dl>
                            <dt><a
                              href="http://voting.app:5000">http://voting.app:5000</a></dt>           
                            <dd>To vote</dd>
                            <dt><a
                              href="http://voting.app:5001">http://voting.app:5001</a></dt>
                            <dd>To see results</dd>
                            <dt><a
                              href="http://voting.app:8080">http://voting.app:8080</a></dt>
                            <dd>To visualise running containers</dd>
                        </dl>
                    </section>
                    <section>
                        <h3>Scale services</h3>
                        <pre><code>$ docker service scale vote_vote=3</code></pre>
                        <p>
                        Look at the changes in the <a href="http://voting.app:8080">visualizer</a>
                        </p>
                    </section>

                    <section>
                        <h3>Update a service</h3>
                        <pre><code>$ docker service update --image heytrav/vote vote_vote</code></pre>
<asciinema-player autoplay="1" loop="loop"  font-size="medium" speed="1"
    theme="solarized-light" src="lib/asciicast-120564.json" cols="146"
    rows="10"></asciinema-player>
<p>
Now go to the <a href="http://voting.app:5000">voting app</a> and verify the change
</p>
                    </section>
                    <section>
                        <h3>Developer workflow</h3>
                        <ul>
                            <li class="fragment" data-fragment-index="0">Push code to repository</li>
                            <li class="fragment" data-fragment-index="1">Continuous Integration (CI) system runs tests</li>
                            <li class="fragment" data-fragment-index="2">If tests successful, automate image build &amp; push to a docker registry</li>
                            <li class="fragment" data-fragment-index="3">Manually/automatically run <code>docker service update</code></li>
                            <li class="fragment"
                                data-fragment-index="4">Easy to setup with
                                existing services and automation tools like
                                Ansible
                                <ul>
                                    <li><a
                                        href="https://hub.docker.com">DockerHub</a>
                                    (eg. <a href="https://hub.docker.com/r/heytrav/docker-introduction-slides/builds/">these slides</a>)</li>
                                    <li><a href="https://github.com">GitHub</a></li>
                                    <li><a href="https://circleci.com">CircleCI</a></li>
                                    <li>GitLab</li>
                                    <li><a href="https://quay.io">Quay.io</a></li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                
                    <section>
                        <h3>Drain a node</h3>
                        <pre><code>$ docker node update --availability drain worker1</code></pre>
                        <ul>
                            <li>
                                Sometimes necessary to take host offline
                                <ul>
                                    <li>Planned maintenance</li>
                                    <li>Patching vulnerabilities</li>
                                    <li>Resizing host</li>
                                </ul>
                            </li>

                            <li>Prevents node from receiving new tasks</li>
                            <li>Manager stops tasks running on node and launches replicas on active nodes</li>
                        </ul>
                        <aside class="notes">
                            This might be necessary if you need to do maintenance
                            on a particular host
                        </aside>
                    </section>
                    <section>
                        <h3>
                            Return node to service
                        </h3>
                        <pre><code>$ docker node update --availability active worker1</code></pre>
                        <ul>
                            <li>during a service update to scale up</li>
                            <li>during a rolling update</li>
                            <li>when you set another node to Drain availability</li>
                            <li>when a task fails on another active node</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Summary</h3>
                        <ul>
                            <li>
                                Created a cluster with a cloud provider using ansible
                                <ul>
                                    <li>1 manager node</li>
                                    <li>2 worker nodes</li>
                                </ul>
                            </li>
                            <li>Deployed microservice for voting app in Docker Swarm</li>
                            <li>Scaled service from 2 to 3 services</li>
                            <li>Rolling-Updated image</li>
                        </ul>


                    </section>
                    <section>
                        <h3>Tear down your cluster</h3>
                        <pre><code>$ ansible-playbook -K  --extra-vars "suffix=-$( hostname )" remove-swarm-hosts.yaml</code></pre>
                    </section>

                </section>

                
                


                <section>
                    <section>
                        <h2>Wrap up</h2>
                    </section>

                <section>
                    <h3>Docker ecosystem</h3>
                    <ul>
                        <li>An explosion of tools</li>
                        <li>Hard to keep up</li>
                        <li>Lets have a quick look</li>
                    </ul>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Docker ecosystem</h2>
                    <img src="img/docker-ecosystem.png" alt="Docker Ecosystem" height="600" width="800">
                    <aside class="notes"><ul>
                      <li>Orchestration: Managing the lifecycle of containers (starting, stopping, etc.) and distributing them across hosts in a cluster.</li>
                      <li>Service Discovery: Manage directories of where services running in containers can find each other in a cluster of hosts.</li>
                      <li>Networking: Virtual networks across hosts in a cluster</li>
                      <li>Linux: Underlying Linux technologies that Docker uses.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>Competing technologies</h3>
                    <ul>
                        <li>rkt (CoreOS)</li>
                        <li>Serverless (FaaS) <ul>
                                <li>Lambda (AWS)</li> 
                                <li>Azure Functions (Microsoft)</li>
                                <li>Google cloud functions</li>
                                <li>iron.io</li>
                            </ul>
                        </li>
                    </ul>
                </section>
                
                </section>

                <section>
                    <section>
                        <h3>The end</h3>
                    </section>
                </section>


                

                <!-- Large image slide -->

                
<!--
                <section>
                    <h3>Scripts</h3>
                    <ul>
                        <li>Designed to be run on trusty training machines</li>
                        <li>docker-setup.sh - ensures required software is installed</li>
                        <li>user-setup.sh - sets up environment variables for our user</li>
                        <li>docker-course.sh - list or run the course commands</li>
                    </ul>
                </section>

                <section>
                    <h3>Checkout code and examples</h3>
                    <pre><code data-trim contenteditable>
    $ git clone https://github.com/heytrav/docker-training
                    </code></pre>
                </section>
                <section>
                    <h3>Setup</h3>
                    <p>lets setup our environment now</p>
                    <pre><code data-trim contenteditable>
cd docker-training
source ./user-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Install Docker</h3>
                    <pre><code data-trim contenteditable>
    $ sudo ./docker-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Course script</h3>
                    <p>By default this script outputs all the commands you will need to run</p>
                    <pre><code data-trim contenteditable>
$ sudo ./docker-course.sh -h

Usage: sudo ./docker-course.sh [OPTIONS]

    -h        this help
    -s        takes an integer, indicates that we should stop at this section
    -r        replay, runs all the commands without user input
    -i        interactive replay, requires keypresses to run commands
                    </code></pre>
                    <p>try it now</p>
                    <pre><code data-trim contenteditable>
sudo ./docker-course.sh -s 3
                    </code></pre>
                </section>

                <section>
                    <h3>1: Dockerizing applications</h3>
                    <a
                           href="https://docs.docker.com/engine/tutorials/dockerizing/">https://docs.docker.com/engine/tutorials/dockerizing/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerizing">(cache)</a>
                       <aside class="notes"><ul>
                               <li>Run simple container.</li>
                               <li>Run interactive container.</li>
                               <li>Run daemonized container.</li>
                               <li>Talk about container IDs.</li>
                               <li>docker ps (with -a for non-running containers)</li>
                               <li>Talk about container names (automatic, and set).</li>
                               <li>docker logs {container} (with -f to follow continuing output)</li>
                               <li>docker stop {container}</li>
                           </ul></aside>
                </section>


                


                <section>
                    <section>
                        <h3>2: Working with containers</h3>
                        <a
                            href="https://docs.docker.com/engine/tutorials/usingdocker/">https://docs.docker.com/engine/tutorials/usingdocker/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/usingdocker">(cache)</a>
                        <aside class="notes"><ul>
                                <li>Docker version</li>
                                <li>Help: docker [command] --help</li>
                                <li>Run web server, explain -P for auto port-mapping.</li>
                                <li>Only non-official images have slashes in the name (which is the DockerHub account name)</li>
                                <li>Docker client defaults to DockerHub, but it can be made to point to another registry (but it is difficult).</li>
                                <li>docker ps "-l" option for last running container.</li>
                                <li>Note PORTS in docker ps output</li>
                                <li>And use -p for custom mappings.</li>
                                <li>Docker port {container} 5000</li>
                                <li>docker logs -f {container} (For web app logs)</li>
                                <li>docker top {container} (To view top output for processes in container (with PIDs of the host, not the container))</li>
                                <li>docker inspect {container} (For container info)</li>
                                <li>docker {start, stop, restart}</li>
                                <li>Ports auto-allocated with -P may be different after restart.</li>
                                <li>docker rm (with stop first)</li>
                            </ul></aside>
                    </section>

                    <section>
                        <h3>2: Working with containers</h3>
                        <ul>
                            <li>Run a basic application</li>
                            <li>Run a more complex web application</li>
                            <li>Some networking</li>
                        </ul>
                    </section>
                    <section>
                        <h3>More Examples</h3>
                    </section>

                    <section>
                        <h3>Talking to our detached container</h3>
                        <pre>
                        
$ docker ps -l

CONTAINER ID  IMAGE                   COMMAND...
bc533791f3f5  training/webapp:latest  python app.py ...

$ docker logs -f <container>                        
                        </pre>
                        <p>Meanwhile in another shell</p>

                        <pre>
curl http://&lt;hostname&gt;:32768
Hello world!%
                        </pre>
                    </section>
                    <section>
                        <h3>Create, start, stop and remove a container</h3>
                        <pre>
$ docker create --name myflaskapp -p 8080:5000 training/webapp python app.py
a842945e2414132011ae704b0c4a4184acc4016d199dfd4e7181c9b89092de13
$ docker ps -a

CONTAINER ID        IMAGE                  COMMAND...
8a73bcb9b7b8        training/webapp        "python app.py"...

$ docker start myflaskapp
a842945e2414

$ docker ps
CONTAINER ID        IMAGE               COMMAND
8a73bcb9b7b8        training/webapp     "python app.py"...

$ docker stop myflaskapp
$ docker rm myflaskapp
                        </pre>
                    </section>
                </section>

                <section>
                    <h3>3: Get started with images</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockerimages/">https://docs.docker.com/engine/tutorials/dockerimages/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerimages">(cache)</a>
                    <aside class="notes"><ul>
                      <li>docker images (To list images)</li>
                      <li>Careful not to chew up space with too many images.</li>
                      <li>An image is a base image, plus all FS layers on top.</li>
                      <li>Talk about tags (default tag when none is specified is latest)</li>
                      <li>docker pull centos (Pulling independent of running)</li>
                      <li>docker search sinatra</li>
                      <li>docker pull training/sinatra</li>
                      <li>Run the container, make changes, run commit.</li>
                      <li>commit creates a new image using a read-only version of the UFS layer the changes were made to.</li>
                      <li>Generally better to use a Dockerfile (it must have that name)</li>
                      <li>Create sinatra folder+Dockerfile, and explain contents</li>
                      <li>Each instruction in a Dockerfile creates a new layer.</li>
                      <li>docker build</li>
                      <li>Everything in the same directory as the Dockerfile is sent to the Docker daemon as "context" (so don't put a Dockerfile in your home directory).</li>
                      <li>To keep image sizes small, remove apt-cache (in the same instruction as installing dependencies), and remove other unnecessary cruft before it is added in a layer.</li>
                      <li>Max layers: 127</li>
                      <li>docker tag (To tag an image)</li>
                      <li>Digests don't seem to work correctly, and seem to overlap with SHA IDs.</li>
                      <li>You can push to DockerHub</li>
                      <li>docker rmi (To remove images, not to be confused with rm for containers)</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>4: Networking containers</h3>
<a
    href="https://docs.docker.com/engine/tutorials/networkingcontainers/">https://docs.docker.com/engine/tutorials/networkingcontainers/</a> (new in 1.9 was <a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/">Dockerlinks</a>)
                    <aside class="notes"><ul>
                      <li>Networking used to be handled through "Docker links" (one way exposing of ports between containers), which are now deprecated.</li>
                      <li>docker run --name (Naming a container)</li>
                      <li>You can create networks for your containers to sit on (specifying a driver (e.g. bridge driver on local machine, overlay driver across machines))</li>
                      <li>You'll want to create your own networks to isolate containers from each other in more complex setups.</li>
                      <li>List networks with: docker network ls</li>
                      <li>"bridge" is a special network that all cotnainers are added to by default.</li>
                      <li>You can "docker inspect {network}" to find out container IP addresses</li>
                      <li>docker network create</li>
                      <li>docker network connect/disconnect</li>
                      <li>Start a container on a network with --net</li>
                      <li>Inspect a container to see network information (it can be on multiple networks).</li>
                      <li>Start 2 containers on the same network, and ping each other.</li>
                      <li>When you connect a container to a network, Docker updates /etc/hosts on the other hosts so they can refer to it by its container name.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>5: Managing data in containers</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockervolumes/">https://docs.docker.com/engine/tutorials/dockervolumes/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockervolumes">(cache)</a>
                    <aside class="notes"><ul>
                      <li>Data volumes are like the "mount" command; they bypass the UFS.</li>
                      <li>You can mount a directory from the host, or just a standalone volume.</li>
                      <li>docker run -v /webapp OR specify in Dockerfile</li>
                      <li>You can set read-only permissions on a volume (:ro).</li>
                      <li>A container's volumes are not deleted when it is deleted.</li>
                      <li>docker inspect {container} (To see volume info under "Mounts")</li>
                      <li>docker run -v /src/webapp:/opt/webapp</li>
                      <li>host_directory:container_directory</li>
                      <li>You can mount individual files</li>
                      <li>Pattern: Put all your data volumes in a single container, then use --volumes-from to share them with other containers. This means that you can safely delete the other containers without losing a container with a reference to the volume.</li>
                      <li>To remove volumes along with a container, use: docker rm -v</li>
                      <li>Removing a container without removing volumes will create dangling volumes which will need to be manually deleted.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>6: Get started with Docker Hub</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockerrepos/">https://docs.docker.com/engine/tutorials/dockerrepos/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerrepos">(cache)</a>
                    <aside class="notes"><ul>
                      <li>DockerHub has similar webhook and automation capabilities to GitHub.</li>
                    </ul></aside>
                </section>


[>
   -                
   <]

                <section>
                <section>
                    <h3>8: More on Dockerfiles</h3>
                    <ul>
                        <li><a
                                href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Dockerfile Best Practices</a></li>
                        <li><a href="https://github.com/nginxinc/docker-nginx/blob/4e5332fa50a1f8f73657417c6bfe249bbb3b110d/dockerfile">Nginx Dockerfile</a></li>
                        <li><a href="https://github.com/docker-library/postgres/blob/8a9fbcb40f13ccc7762f278b9df611cabe22d300/9.5/dockerfile">Postgres Dockerfile</a></li>
                        <li><a href="https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/">ENTRYPOINT vs CMD</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><strong>Dockerfile Best Practices</strong></li>
                      <li>Go over main points in recommendations</li>
                      <li>Explain layer caching, and cache-busting with changed lines and --no-cache=true</li>
                      <li>Never run apt-get upgrade or dist-upgrade (they may not work in a container), always depend on the base image to be updated.</li>
                      <li>Look at apt-get recommendations (update in same instruction, version pinning, clearing apt lists)</li>
                      <li>Prefer COPY instead of ADD (which has fancy features such as remote URLs and tar expansion)</li>
                      <li><strong>ENTRYPOINT vs CMD</strong></li>
                      <li>CMD is overriden by whatever the user supplies as the command.</li>
                      <li>ENTRYPOINT prefixes the command, so is good as a "wrapping command" for other subcommands. E.g. git</li>
                      <li>ENTRYPOINT can be overriden with --entrypoint</li>
                      <li>CMD can be used to contain default options for the ENTRYPOINT</li>
                      <li>Prefer CMD/ENTRYPOINT exec form (["/bin/ping" "-c" "3"]) over shell form ("ping -c 3", which is executed as "/bin/sh -c ping -c 3") so that the process itself is PID 1, not the shell (useful for Docker control signals).</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>See <a href="https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/">https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/</a> for details</li>
                        <li>Lets look at some images: <a href="https://imagelayers.io/?images=debian:latest,ubuntu:latest,alpine:latest">https://imagelayers.io/?images=debian:latest,ubuntu:latest,alpine:latest</a></li>
                    <pre><code data-trim contenteditable>
$ sudo docker run -i -t debian
root@0f94a65e7d37:/# exit
$ sudo docker run -i -t alpine
Error response from daemon: No command specified
                    </code></pre>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost/dockerfile
FROM debian:jessie
CMD ping localhost
$ sudo docker build -t demo dockerfiles/ping-localhost
$ sudo docker run -t demo
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.054 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.064 ms
$ docker run demo uname -a
Linux fac4960db319 3.13.0-66-generic #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Use CMD when you want the user to have the choice of commands to run</li>
                        <li>Use ENTRYPOINT when you want to wrap a command</li>
                        <li>ENTRYPOINT can be overridden with the --entrypoint flag</li>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/python/dockerfile
FROM python
ENTRYPOINT ["python"]
$ sudo docker build -t python dockerfiles/python
Sending build context to docker daemon 2.048 kB
Step 0 : FROM python
-<] e7d942e7369d
Step 1 : ENTRYPOINT python
-<] Using cache
-<] c3b6fc104517
Successfully built c3b6fc104517
$ sudo docker run -ti python
Python 3.5.0 (default, Nov 11 2015, 10:39:25)
[GCC 4.9.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> exit()
$ sudo docker run --entrypoint uname -t python
Linux
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ sudo docker run -d demo
f27197f4370c2981792ab3d09a0620c1c8f7c993cb66770ffc1f1aa6c4dfe021
$ docker ps -l
CONTAINER ID IMAGE     COMMAND                 CREATED        STATUS         PORTS NAMES
f27197f4370c dojo/demo "/bin/sh -c 'ping loc"  11 seconds ago Up 10 seconds        suspicious_leakey
$ sudo docker exec f27197f4370c ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 08:21 ?        00:00:00 /bin/sh -c ping localhost
root         5     1  0 08:21 ?        00:00:00 ping localhost
root         6     0  0 08:21 ?        00:00:00 ps -f
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Shell form vs Exec form</li>
                        <li>Don't mix and match</li>
                        <li>Use exec</li>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost-exec/dockerfile
FROM debian:jessie
CMD ["ping", "localhost"]
$ sudo docker build -t demo dockerfiles/ping-localhost-exec/
...
$ sudo docker run -d demo
db7526643dbe7ec6d6f27aa707539aa67a3573a8adc7754372d8fce0fe824cfc
$ sudo docker exec db7526643dbe ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 08:27 ?        00:00:00 ping localhost
root         6     0  0 08:27 ?        00:00:00 ps -f
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost-both/dockerfile
FROM debian:jessie
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]
$ sudo docker build -t ping dockerfiles/ping-localhost-both
$ sudo docker run ping google.com
$ sudo docker run ping
                    </code></pre>
                </section>
                </section>

                <section>
                    <h3>9: Base images</h3>
                    <ul>
                        <li>Size is a major consideration ... deploy times ...</li>
                        <li>FROM empty ...</li>
                        <li><a href="http://www.busybox.net/">Busybox</a> - 5.6 MB, no package manager</li>
                        <li><a href="https://www.alpinelinux.org/">Alpine Linux</a> - distribution of choice for minimal containers - 5MB with a package manager (based on busybox)</li>
                        <li><a href="https://hub.docker.com/_/debian/">Debian</a> - Reccomended by Docker, smaller than Ubuntu - 85MB</li>
                        <li><a href="https://hub.docker.com/_/ubuntu/">Ubuntu</a> - Commonly used but quite big</li>
                        <li>Language images (<a href="https://hub.docker.com/_/golang/">golang</a>, <a href="https://hub.docker.com/_/python/">python</a> etc.) - Seem to be mostly based on Debian</li>
                        <li>See <a href="http://www.blang.io/posts/2015-04_how-to-build-the-smallest-docker-containers">1</a>, <a href="http://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux">2</a>, <a href="https://docs.docker.com/articles/baseimages/">3</a></li>
                    </ul>
                </section>

                <section>
                <section>
                    <h3>10: Docker networking</h3>
                    <img src="http://www.linuxjournal.com/files/linuxjournal.com/ufiles/imagecache/large-550px-centered/u1002061/11833f1.png" alt="docker networking">
                    <aside class="notes"><ul>
                      <li>docker starts a "docker0" virtual bridge to handle host-container communication.</li>
                      <li>When a container starts, Docker creates a virtual interface on the host (e.g. veth9999999), which is connected to the eth0 interface of the container.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>10: Docker networking</h3>
                    <ul>
                        <li>docker0 virtual bridge</li>
                        <li>172.17.42.1/16 by default</li>
                        <li>Part of the 172.16.0.0/12 RFC 1918 space</li>
                        <li>Sets up virtual ether net ports on the host (eg veth31a763b)</li>
                        <li>Sets up a DOCKER Chain in iptables</li>
                        <li>Mounts hosts /etc/resolv.conf and /etc/hosts in containers</li>
                    </ul>
                </section>
                <section>
                    <h3>10: Docker networking</h3>
                    <pre><code data-trim contenteditable>
# try these commands your the host
# use your own container name
$ sudo iptables -L
$ sudo ip addr
$ sudo docker exec -it stoic_ramanujan findmnt
$ sudo cat $(sudo docker exec -it stoic_ramanujan findmnt | grep resolv | awk -F'[][]' '{ print $2 }')
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 192.168.2.92
search wgtn.cat-it.co.nz lan
                    </code></pre>
                    <aside class="notes">Shows that the resolv.conf is mounted in the container, as well as iptables rules.</aside>
                </section>
                </section>

                <section>
                <section>
                    <h3>11: Exec vs Attach</h3>
                    <ul>
                        <li>Exec is specifically for running new processes in an already started container, be it a shell or some other process</li>
                        <li>Attach is for attaching to the running process, not for running an extra process in a container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Exec</h3>
                    <ul>
                        <li>The Docker exec command runs a <strong>new</strong> command (process) in a running container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Attach</h3>
                    <ul>
                        <li>Attach lets you view or interact with any running container's primary process (pid 1) </li>
                        <li>You can attach to the same contained process multiple times simultaneously, screen sharing style</li>
                        <li>View the output of your daemonized process</li>
                        <li>Not for running a new process in a container</li>
                    </ul>
                </section>
                </section>


                [> Immutable Infrastructure <]

                [> Microservices <]

                <section>
                    <h3>Devops</h3>
                    <ul>
                        <li>You build it you run it</li>
                        <li>With Docker it is easier to make a distinction between who "owns" the service and who "owns" the platform the service runs on</li>
                        <li>Because dev is like production the developer thinks about how it runs in production</li>
                    </ul>
                </section>

                 [> Continuous delivery <]
                <section>
                <section>
                    <h3>Continuous delivery</h3>
                    <ul>
                        <li>Automated Pipeline from developer commit to production deploy</li>
                        <li>Requires Continuous Integration where every commit triggers all the tests</li>
                        <li>Requires lots of tests</li>
                    </ul>
                </section>
                <section>
                  <h3>Continuous delivery</h3>
                  <img src="img/ci-diagram.png" alt="Continuous delivery">
                </section>
                <section>
                    <h3>Continuous delivery antipatterns</h3>
                    <ul>
                        <li>Deploying software manually</li>
                        <li>Deploying to a production-like environment only after development is complete</li>
                        <li>Manual configuration of production environments</li>
                        <li>Docker makes it difficult to do any of these</li>
                    </ul>
                </section>
                </section>

                 [> Where to start? <]
                <section>
                <section>
                    <h3>Containers: Where to start?</h3>
                    <ul>
                        <li>Building binaries</li>
                        <li>Prototypes you can share</li>
                        <li>Tutorials</li>
                        <li>Those small snowflakes</li>
                        <li>Build new functionality as microservices</li>
                        <li>Existing components that are already largely independent</li>
                        <li>Mix and match, containerise the bits that make sense</li>
                    </ul>
                </section>
                <section>
                    <h3>Examples</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/07/docker-three-ways-devops-3/">Distributing (scientific) data</a></li>
                        <li><a href="https://github.com/VISIONAI/clouddream">Distributing clouddream</a></li>
                        <li><a href="https://github.com/CenturyLinkLabs/golang-builder">Compiling go</a></li>
                    </ul>
                </section>
                 [> Large image slide <]
                <section class="image-slide">
                    <h2>Bosch Dreaming</h2>
                    <a href="img/Hieronymus_Bosch_003.jpg"><img src="img/Hieronymus_Bosch_003.jpg" alt="Bosch Dream" height="600" width="800"></a>
                </section>
                </section>

                [> ecosystem <]
                <section>
                <section>
                    <h3>The stack</h3>
                    <ul>
                        <li>The LAMP stack equivalent</li>
                        <li>Container Orchestration Engines</li>
                        <li>Linux - Docker - COE - ?</li>
                        <li>Often LDK (Linux - Docker - Kubernetes)</li>
                        <li>Higher level projects build on this stack (eg OpenShift and CloudFoundry)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Host OS</h3>
                    <p>Lightweight operating systems designed to run containers</p>
                    <ul>
                        <li><a href="https://coreos.com/">CoreOS</a> (systemd)</li>
                        <li><a href="http://www.projectatomic.io/">Project Atomic</a> (cut down RHEL)</li>
                        <li><a href="http://rancher.com/">Rancher</a> (Dockers all the way down)</li>
                        <li><a href="http://boot2docker.io/">boot2docker</a> (for windows/mac devs)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Container Orchestration Engines</h3>
                    <p>Engine for orchestrating container workloads, term comes from the OpenStack Magnum project.</p>
                    <p>There are two main classes of orchestration tooling:</p>
                    <ul>
                        <li><strong>Simple orchestration tools</strong> for deploying on pet servers</li>
                        <li><strong>Distributed schedulers</strong> for deploying on cattle server farms</li>
                    </ul>
                </section>
                <section>
                    <h3>Simple orchestration tools</h3>
                    <ul>
                        <li>Tools to simply deploy containers onto servers.</li>
                        <li>Simple way to get many benefits of Docker in production.</li>
                        <li>E.g. Centurion, Helios, Docker modules for Ansible and Puppet.</li>
                    </ul>
                </section>
                <section>
                  <h3>Docker + Ansible Deployments</h3>
                  <img src="img/docker-ansible-diagram.png" height="600">
                </section>
                <section>
                    <h3>Distributed schedulers</h3>
                    <ul>
                        <li>Make a cluster appear to be a single computer.</li>
                        <li>More complex, but have more of the benefits associated with immutable infrastructure, etc.</li>
                        <li><a href="http://radar.oreilly.com/2015/10/swarm-v-fleet-v-kubernetes-v-mesos.html">Swarm v. Fleet v. Kubernetes v. Mesos</a></li>
                    </ul>
                </section>
                </section>

                [> Docker compose <]
                <section>
                <section>
                    <h3>Docker compose</h3>
                    <ul>
                        <li>Mainly used for spinning up multi-container development/testing environments.</li>
                        <li>Written in python rather than go like most of Docker</li>
                        <li>Comparable to vagrant</li>
                        <li>New lib written in go called <a href="http://rancher.com/our-journey-with-docker-compose-and-the-introduction-of-libcompose/">libcompose</a></li>
                        <li>Lots of documentation will mention (now obsolete) links, you can generally just remove links configuration.</li>
                    </ul>

                </section>
                <section>
                    <h3>Docker compose</h3>
                    <a href="https://docs.docker.com/compose/">Overview of Docker Compose</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/compose/">(cache)</a>
                </section>
                <section>
                    <h3>Docker compose - hands on</h3>
                    <a href="https://docs.docker.com/compose/gettingstarted/">Example app</a>
                </section>
                </section>

                [> Docker swarm <]
                <section>
                    <h3>Docker swarm</h3>
                    <ul>
                        <li>Native clustering for Docker</li>
                        <li>Use standard tools to interact with a cluster of Docker engines</li>
                        <li>Turn a group of Docker engines into a single, virtual Docker engine</li>
                        <li>Engines can be deployed using Docker machine (<a href="http://docs.catalystcloud.io/tutorials.html#create-an-a-cloud-vm-using-docker-machine">example</a>)</li>
                    </ul>
                </section>

                [> Kubernetes <]
                <section></section>

                 [> Managing state <]
                <section>
                <section>
                    <h3>Managing State</h3>
                    <p>"In a cluster of ephemeral containers application state must exist outside of the containers."</p>
                    <p>Ian Lewis, Google - <a href="https://speakerdeck.com/ianlewis/in-a-world-of-ephemeral-containers-how-do-we-keep-track-of-things-at-openstack-summit-tokyo">In a World of Ephemeral Containers, How Do We Keep Track of Things? @ OpenStack Summit Tokyo</a> (<a href="https://www.youtube.com/watch?v=aYs7IxMQzgg">video</a>)</p>
                </section>
                <section>
                    <h3>Initial state</h3>
                    <p>All containers start with exactly the same state which is derived from the image they are instantiated from.</p>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                        <li>Source Code?</li>
                    </ul>
                </section>
                <section>
                    <h3>Managing Volumes</h3>
                    <ul>
                        <li>Normal Docker volumes are per host</li>
                        <li>Kubernetes Persistent volumes</li>
                        <li>Docker Engine 1.9 includes redesigned volume system with more plugins (eg <a href="https://docs.clusterhq.com/en/1.7.1/introduction/what-is-flocker.html">Flocker</a>)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Managing state - CAP</h2>
                    <p>Managing state can be tricky</p>
                    <img src="img/cap.png" alt="CAP" height="600" width="800">
                    <aside class="notes">
                      Managing state in clustered environments is not
                      unique to Docker. There are many database
                      solutions, each with its own pros and cons.
                    </aside>
                </section>
                <section>
                    <h3>Patterns for Managing State</h3>
                    <ul>
                        <li>Outside the cluster (SEP)</li>
                        <li>Adapted to run in cluster (eg MySQL inside cluster with data volume for persistence)</li>
                        <li>Cluster native (eg Cassandra or Riak)</li>
                        <li><a href="http://vitess.io/">vitess.io</a></li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Patterns for Composite Containers</h3>
                    <p>
                    <a href="http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html">http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html</a> (<a href=blog/">local</a>).
                    </p>
                    <ul>
                        <li>Sidecar containers (eg logger, git synchroniser)</li>
                        <li>Ambassador containers (local proxy to a service of unknown size)</li>
                        <li>Adapter containers (normalize and abstract different services)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Sidecar containers</h2>
                    <ul>
                        <li>Modular and pluggable</li>
                        <li>Reuse sidecar for different frontends</li>
                        <li>Different team can maintain the sidecar</li>
                        <li>Lower complexity inside specific containers</li>
                    </ul>
                    <img src="img/sidecar.png" alt="Sidecar">
                    <aside class="notes">
                      Sidecar containers provide re-usable
                      functionality that enhances
                      another container.
                      <br>
                      The example here shows a webserver container server files from
                      a data volume. The data volume is shared with a
                      sidecar container that synchronises the files
                      with a Git repository, thus providing Git
                      push-to-deploy. The sidecar can be re-used to
                      provide git-syncing in other contexts.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Ambassador containers</h2>
                    <ul>
                        <li>Its a proxy ...</li>
                        <li>The solution behind the proxy can be as simple or complicated as the environment requires</li>
                        <li>Also modular, reuse, lower complexity per container</li>
                    </ul>
                    <img src="img/ambassador.png" alt="Ambassador">
                    <aside class="notes">
                      Example is of an ambassador container to act
                      like a normal redis server, while it is really a
                      proxy for a redis cluster.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Adapter containers</h2>
                    <ul>
                        <li>When containers want to talk to other systems</li>
                        <li>Use adaptors to translate so that neither ends needs native support for each other protocols</li>
                        <li>eg, monitoring systems, convert from app specific output to monitoring system format</li>
                    </ul>
                    <img src="img/adapter.png" alt="Adapter">
                    <aside class="notes">
                      In the example, the redis logs are converted
                      into a standard format by an adapter container,
                      so that the monitoring system only needs to know
                      the standard format that all adapters provide.
                    </aside>
                </section>
                </section>

                [> Security <]
                <section>
                <section>
                    <h3>Security</h3>
                    <ul>
                        <li>How do you keep track of all the versions of all the software in all the containers?</li>
                        <li>The way to apply security updates is to update the base image, then rebuild your application image</li>
                        <li>If you release often then include an updated base every time you release (plus special releases for heartbleeds)</li>
                        <li>If you release infrequently then do base update releases of your app</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Image Signing</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/08/content-trust-docker-1-8/">Intoduction to Docker Content Trust</a></li>
                        <li>Provided by the <a href="https://github.com/docker/notary">Notary</a> open source project</li>
                        <li>Based on <a href="http://theupdateframework.com/">The Update Framework</a></li>
                        <li><a href="https://www.youtube.com/watch?v=at72dhg-SZY&feature=youtu.be&t=4873">Video</a></li>
                        <li><a href="https://docs.docker.com/engine/security/trust/content_trust/">Content Trust Documentation</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Notary is a general purpose tool for signing files.</li>
                      <li>You can enable "Docker Content Trust" so that you can sign images that other Docker uses can verify.</li>
                      <li>Currently only available with DockerHub.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Security - Image Vulnerability Scanning</h3>
                    <ul>
                        <li><a href="https://coreos.com/blog/vulnerability-analysis-for-containers/">Intoduction to Clair from CoreOS</a></li>
                        <li><a href="https://github.com/coreos/clair">Clair on github</a></li>
                        <li>Project Nautilus a new image scanning and vulnerability detection service for Official Repos on Docker Hub</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Useful links</h3>
                    <ul>
                        <li>How often do the official base images get updated? (details <a href="https://blog.docker.com/2015/06/understanding-official-repos-docker-hub/">here</a>)</li>
                        <li><a href="https://titanous.com/posts/docker-insecurity">Image signing</a> (see <a href="https://github.com/docker/notary">notary</a>)</li>
                        <li><a href="https://securityblog.redhat.com/2014/12/17/container-security-isolation-heaven-or-dependency-hell/">Level of isolation</a></li>
                        <li><a href="https://d3oypxn00j2a10.cloudfront.net/assets/img/docker%20Security/WP_Intro_to_container_security_03.20.2015.pdf">Introduction to Container Security</a> Whitepaper</li>
                        <li><a href="https://blog.docker.com/2013/08/containers-docker-how-secure-are-they/">Fundamentals</a> (old but informative)</li>
                        <li><a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">Best practices</a></li>
                        <li><a href="https://securityblog.redhat.com/2014/12/18/before-you-initiate-a-docker-pull/">Securely downloading containers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Information about official repos</li>
                      <li>Existing issues with image verification.</li>
                      <li>Limitations of containers (Shared kernel etc.)</li>
                      <li>Whitepaper on container security</li>
                      <li>Explanation of how Docker works, security implications, and comparisons to VMs and other containerization systems.</li>
                      <li>Best practice recommendations</li>
                      <li>Problems with Docker pull (auto-unpacking), and how to work around it.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Other problems</h3>
                    <ul>
                        <li>Not declarative (Dockerfiles)</li>
                        <li>Not idempotent or repeatable (E.g. apt-get install)</li>
                        <li><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">Pids and spawning issues</a> (Zombie processes)</li>
                        <li>Standardisation</li>
                        <li>See <a href="https://www.youtube.com/watch?v=wpFrkq5XNFM">these</a> <a href="https://www.youtube.com/watch?v=et7BCV_kAUY">talks</a> from systemd.conf</li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Q: How can I monitor my containers?</p>
                    <p>A: Try sysdig/csysdig</p>
                    <ul>
                        <li>sudo csysdig</li>
                        <li>hit F2 and choose the Containers view</li>
                        <li>can also monitor <a href="http://blog.kubernetes.io/2015/11/monitoring-Kubernetes-with-Sysdig.html">kubernetes</a></li>
                    </ul>
                    <aside class="notes">csysdig has a curses UI.</aside>
                </section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Lets build a Docker image for some testing:</p>
                    <pre><code data-trim contenteditable>
$ cat ~/src/docker-training/dockerfiles/stress-testing/dockerfile
$ sudo docker build -t stress-test ~/src/docker-training/dockerfiles/stress-testing/
$ sudo docker run stress-test stress --help
$ sudo docker run [DOCKER OPTIONS] stress-test stress [STRESS OPTIONS]
                    </code></pre>
                </section>
                <section>
                    <h3>Monitoring and CPU limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run --cpuset-cpus=0,1 stress-test stress -c 3
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Here we limit Docker to using the first 2 CPUs (0 and 1).
                      <br>
                      htop shows usage per CPU.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring and Memory limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run -m 512M stress-test stress --vm-bytes 256M -m 4
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Limit the container to 512MB of RAM and 512MB of swap.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring - check-config</h3>
                    <p>How to enable swap limiting:</p>
                    <pre><code data-trim contenteditable>
$ check-config.sh # Check that the kernel supports it.
# Edit /etc/default/grub:
# GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"
                    </code></pre>
                </section>
                </section>

                <section>
                <section>
                    <h3>FAQ</h3>
                    <ul>
                        <li><a href="http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/">Why is sudo required?</a></li>
                        <li><a href="http://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/">What are the &lt;none&gt;&lt;none&gt; images I see and how can I clean them up?</a></li>
                        <li><a href="https://docs.docker.com/articles/baseimages/">Can I build my own base image?</a></li>
                        <li><a href="https://stackoverflow.com/questions/24394243/why-are-docker-container-images-so-large">Why are Docker images so large?</a></li>
                        <li><a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">Does each Dockerfile run command create its own layer?</a></li>
                        <li><a href="https://blog.docker.com/2015/11/docker-multi-host-networking-ga/">What happened to Docker links?</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>sudo is required for kernel features</li>
                      <li>Dangling images (name has been re-used for another image).</li>
                      <li>There is a guide</li>
                      <li>All dependencies from all layers, clean up package manager files to reduce size.</li>
                      <li>Yes</li>
                      <li>Docker's networking has been re-worked to not use links.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Whats the story with Docker top pids?</p>
                    <pre><code data-trim contenteditable>
$ sudo docker top sleepy_cori
UID  PID   PPID C STIME TTY    TIME     CMD
root 30136 2379 0 12:29 pts/32 00:00:00 /bin/bash

$ pstree -s -p $(sudo docker top sleepy_cori | tail -1 | awk '{ print $2 }')
init(1)───docker(2379)───bash(30136)
                    </code></pre>
                    <p>A: Top pids are host pids not namespaces container pids</p>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Should I include my application source code in the image?</p>
                    <p>A: It depends, some people like to mount application source code as <a href-"http://blog.ionic.io/docker-hot-code-deploys/">volume</a>, others checkout source code when <a href="http://michal.karzynski.pl/blog/2015/04/19/packaging-django-applications-as-docker-container-images/">building the image</a>.</p>
                    <p>If you are checking out source code in your Dockerfile you need to be aware of <a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">how caching works</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Copy vs. Add</h3>
                    <p>Q: Should I use Copy or Add in my Dockerfile?</p>
                    <p>A: Use copy unless you actually need the magic add provides (details <a href="https://labs.ctl.io/dockerfile-add-vs-copy/">here</a>).</p>
                </section>
                <section>
                    <h3>FAQ: Docker on the Catalyst Cloud</h3>
                    <p>Q: Whats the easiest way to use Docker on the Catalyst Cloud?</p>
                    <p>A: Have a look at <a href="http://docs.catalystcloud.io/tutorials.html#using-docker-machine-on-the-catalyst-cloud">this tutorial</a> on how to use Docker machine to provision Docker engines on the the Catalyst Cloud</p>
                </section>
                <section>
                    <h3>FAQ: Stop vs. Remove</h3>
                    <p>Q: Are container really ephemeral?</p>
                    <p>A: Stopping a container does not delete its filesystem, it will still be there in /var/lib/docker when you start it again. You need to call Docker rm to delete a container</p>
                </section>
                <section>
                    <h3>FAQ: Mounting volumes in running containers</h3>
                    <p>Q: Can I mount a volume in a running container?</p>
                    <p>A: Its <a href="https://github.com/docker/docker/issues/9849">not currently supported</a> by the CLI but there are some <a href="https://jpetazzo.github.io/2015/01/13/docker-mount-dynamic-volumes/">hacks</a> out there.</p>
                </section>
                <section>
                    <h3>FAQ: History</h3>
                    <p>Q: Can you tell me more about the history of containers and their underlying technologies?</p>
                    <p>A: Watch <a href="https://www.youtube.com/watch?v=YsYzMPptB-k">this talk</a> by Kernel developer James Bottomley at the Tokyo OpenStack summit</p>
                </section>
                <section>
                    <h3>FAQ: Exec vs. shell CMD</h3>
                    <p>Q: Why is it better to use the exec version rather than the shell version of CMD/ENTRYPOINT?</p>
                    <p>A: As our command is not pid 1 we cannot send POSIX signals to our command</p>
                    <p>A: /bin/sh may not be available in minimal containers</p>
                    <p>More info <a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/">here</a></p>
                    <p>More info about signals <a href="https://labs.ctl.io/gracefully-stopping-docker-containers/">here</a></p>
                </section>
                <section>
                    <h3>FAQ: Docker log rotation</h3>
                    <p>Q: Is logfile rotation configurable?</p>
                    <p>A: <a href="https://docs.docker.com/engine/reference/logging/overview/">Yes</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Digest broken?</h3>
                    <p>Q: Why does the digest command not work?</p>
                    <p>A: You tell me ...</p>
                </section>
                <section>
                    <h3>FAQ: RUN command chaining</h3>
                    <p>Q: Why do you see so many commands chained together on Dockerfile RUN lines?</p>
                    <p>A: There used to be a limited number of layers (was 42 now 127)</p>
                    <p>A: Minimising layers is <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">encouraged</a></p>
                    <p>A: Multiple RUN lines can lead to caching related <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">problems</a></p>
                </section>
                </section>

                <section>
                <section>
                    <h3>Next steps</h3>
                    <p>What would you like to see in an intermediate Docker course?</p>
                </section>
                <section>
                    <h3>Next steps</h3>
                    <ul>
                        <li>Setup private registry</li>
                        <li>Students build custom "microservices"</li>
                        <li>Setup CoreOS on OpenStack</li>
                        <li>Deploy students microservices and create a www router service</li>
                        <li>Define service as a kubernetes pod/service</li>
                        <li>Scale and migrate pods (between OpenStack regions?)</li>
                        <li>Continuous delivery?</li>
                        <li>Let me know!</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Sources</h3>
                    <p>Sources of the material used in this course:</p>
                    <ul>
                        <li><a href="https://github.com/docker/labs/blob/master/beginner/chapters/webapps.md">Webapps with Docker</a></li>
                        <li><a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
                        <li><a href="https://training.docker.com/introduction-to-docker">https://training.docker.com/introduction-to-docker</a></li>
                        <li><a href="http://alandargan.com/using-vagrant-docker/">http://alandargan.com/using-vagrant-docker/</a></li>
                        <li><a href="http://blog.octo.com/en/docker-registry-first-steps/">http://blog.octo.com/en/docker-registry-first-steps/</a></li>
                        <li><a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components">https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components</a></li>
                        <li><a href="http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html">http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html</a></li>
                        <li><a href="http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking">http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking</a></li>
                        <li><a href="https://www.slideshare.net/brendangregg/container-performance-analysis"><em>Container Performance Analysis</em>. Brendan Greg</a></li>
                    </ul>

                </section>
    <section>
        <h3>Basic Docker Examples</h3>
        <ul>
            <li>Run "Hello, World" in a container</li>
            <li>Interact with a container</li>
            <li>Daemonise a container</li>
        </ul>
    </section>
    <section>
        <h3>More Examples</h3>
    </section>-->

        </div>


        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script src="js/asciinema-player.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

                // Parallax scrolling
                // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
                // parallaxBackgroundSize: '2100px 900px',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
